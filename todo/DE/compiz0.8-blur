Wed 15 Jun 2016 12:55:04 PM NZST
好奇怪,reddit上面那个compiz用的滤镜明显改觉比我的大很多,难道他改源码了?

Wed 15 Jun 2016 01:57:35 PM NZST
https://github.com/compiz-reloaded/compiz/commit/523c2ab814422e4d88ba89bcfa01cfc37ff75bd6
我想这是了解compiz blur kernel的关键.
主要的差别是,0.8存放kernel的手法似乎和compton不一样,并不是矩阵形式的,我估计是为gaussian特别设计的一维数组.
似乎找到了,buffer似乎是2048的限制

实际上代码中似乎有很多1024 2048的限制,1024和28**2很接近

麻烦的是,gpu操作方面,感觉其中似乎混杂了一些很像汇编的东西
已知存在的大数字:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 32, 50, 100, 200, 1000, 1024, 2007, 4096, 8192, 65535, 1000000, 20070830
73以下可以排除嫌疑.
50是我设置的,100是option,200也是我设置的,1000是time,大概是毫秒
1024出现很多,最可疑
2007是年份
4096也很可疑,但是看着像是存放gl程序的字符串
8192似乎是window property
65535以上似乎就太大了,应该是无关的的.
因此,重点排查应该是1024了.
的那是很多1024似乎都是char类型,估计是字符串
检查过后觉得,1024的确只是字符串,而且也不涉及循环,是定长字符串
但是,4096倒是挺可疑的,因为其中涉及了循环了.
循环次数是numTexop,numTexop被bs->amp引用了找不到numTexop的赋值.
amp的大小是  BLUR_GAUSSIAN_RADIUS_MAX
所以感觉这里是存在关联性的.那么我们就试下吧

哈哈，一次到位，果然是这里的数组溢出了.

Wed 15 Jun 2016 04:04:27 PM NZST
进一步的问题，提升radius现在不会导致compiz崩溃了,
但是,如果我们设定str为0.1,那么radius到30以后,似乎就没有进一步的效果了.
如果str为0,那么极限是i,
如果str为0.01,效果似乎和0一样,有奇怪的小数点溢出问题.
因为似乎用了一个pascal的整数算法,我想的确是哪里的小数位数溢出了.
到头来,极限效果依然和15/0.1比没有差别

Wed 15 Jun 2016 04:13:06 PM NZST
进一步的源码分析,我们可疑假设下,amp变量就是kernal,那么我们可疑改动amp,来确认下,
改动amp为中心为1,其余为0,那么就是普通的transparent了.
模仿过后,我们知道,当str为0的时候,其实不是guassian效果,kernel恒为1.0

我怀疑,ccsm无法传递太小的数字到程序,那么我们不如在blur.c中设定strength为1/100,然后在ccsm中可疑用更高精度调整strength

Wed 15 Jun 2016 04:58:23 PM NZST
寻找radius极限的办法很简单,设定strength为0,radius在10,和希望的数值之间切换,会产生差异效果.
极限是50,50以上切换依旧是10的效果.compiz没有崩溃,大概和之前的崩溃不同,不涉及cpu溢出,
我想崩溃的是gpu编译,编译失败,所以没有生成新的效果,
因此确认了上限是50,

对应的,strength的下限是0.05,否则会觉得blur效果似乎变方了.

总得来说勉强比初始的15/0.1效果好一些

和compton不同的是,虽然radius设到了50,但是没有感觉到性能下降

Wed 15 Jun 2016 06:15:50 PM NZST
确认是用的是ARB assembly language
也就是汇编咯

Wed 15 Jun 2016 06:25:50 PM NZST
尝试输出汇编后发现，radius超过50的时候，似乎在得到汇编之前，就产生错误了

Wed 15 Jun 2016 06:33:10 PM NZST
更为奇异的是，如果设定radius为12，然后改到120，12会输出一次arb，120不会，
但是如果更改str，这个时候会输出arb,而且其中的数值就是12,而不是120
就好象120 在哪里被截获了,而内部变量依旧是12
在哪里截获的呢?
原来是我自己之前忘了把那个数值改到200了

这样子就什么都解决了。
比较合适的数值是radius100，在拖动窗口的时候，略微可以感觉到有点迟缓,有点性能吃力,这个程度刚刚好.
比compton性能好很多,compton是达不到这个水平的.应该是因为这个程序优化过了.
对应的strength可疑设定在.03,那么在中位,的数值是0.076(对比正中心),边界是0.003,这样的边界似乎有些多余,我们可以适当缩减边界,减少性能消耗.
其实这里的边界适宜度,应该通过积分来计算,到底有百分之多少被丢弃了.太麻烦了,所以就大概估计下吧.

调整到80/.03,这样边界就是0.012了,这个数值应该差不多了

Wed 15 Jun 2016 06:51:30 PM NZST
一个问题是blur和wall一起用的时候,如果radius到了100,3x3的workspace,那么耳机会有电流声,
80 radius的时候,不论3x3还是5x5,启动wall的一瞬间有电流声音,之后就没有了.
这一点而且和当前桌面开启的程序也毫无关系.
不论把wall中的颜色改成全部实色还是全透明也没有帮助.这中情况下照理blur是不工作的.
不过,反正我们用radius80,所以全部问题到此了解

但是,如果桌面上有blur,开启wall的话,即时80也会有噪音
当然问题根本是这台电脑电源管理有问题.
另外,和reddit对比起来,80 0.03还远不及其效果吧.感觉他的radius可能达到200了,概不会是ps的吧.
不过docky看起来有点接近mac了,估计mac或许radius在150左右.
总觉得reddit那份可能是400,500左右,我看我150的效果还不及他一半

现状是,我们可疑调整到190,性能并无大碍,虽然有耳机噪音

190的效果已经和mac很想像,虽然达不到reddit的程度,但是我想如果我们进一步提升可能就过头了,因为颜色会都混到一起去的.
800会卡到动弹不得。
500是性能极限，开机可能无法加载wallpaper，wall完全不流畅，expo中窗口没有blur
300wall还是不流畅,expo也没有blur
200wall就只是轻微不流畅，expo与其说是没有blur，不如说是blur效果怪异，太黑了.
100似乎就没什么问题了,除了电流声
80在有blur窗口的情况下有电流声
50没有

之前我说错了，电流声不是耳机里的，好像是机箱里的

不考虑电流声音的话,日常可以用150,差不多感觉是mac等级了,80的话就会感觉到有差异,差异就是80能勉强分辨背景细节,mac是几乎模糊掉这些细节的.
要截图像reddit的话,可以上500,接近一个光滑平面.虽然略卡,但是不调用expo和wall的话,其实大问题也没有.

Wed 15 Jun 2016 08:12:39 PM NZST
有一个问题,0.8 的blur是依据alpha决定的,
但是qml的shadow也是属于alpha的,所以这些shadow会产生blur效果,细看会有点怪异.
解决方法很简单,想办法把这部分qml排除就可以了,不过这只前我们要先学会编译qml

整体上来说,我还是喜欢透明的qml而不是blur的,因为qml总是占据很大面积,blur并不好,所以暂且把qml排除blur之外吧.

2016-07-05 07:53:19 Tue NZST
compiz blur是依据opacity来调整blur强度的.
因此只有opacity高的时候,blur才会有效果,低的时候就没有效果.
我们可以做成根据opacity mod 4,来调整blur强度.

确切的说,眼下的机制是0.25以上,blur有效,以下,是看似原图和blur的混合物.也就是说原图的细节被保留了.

看来似乎是没有blur强度一说了,blur强度是固定的,但是blur似乎作为另一个层,有自己的透明度

2016-07-06 20:33:45 Wed NZST
有一个bug,在rotation之后,blur会异样,blur被拉长,原因应该是因为高宽比被放入了gl程序了
而rotation之后程序没有重新编译.
这个时候在ccsm中调整下参数出发程序重编译的话,就会修正这个问题.

2016-07-06 21:57:56 Wed NZST
compiz blur机制理解.
第一,靠后的窗口blur的时候,会混入靠前的窗口的颜色.
这说明,流程是,先画好整个桌面,包括透明度
然后找到当前窗口需要alphablur的区域,在这个区域以整个桌面,除当前窗口以外进行blur.
能排除当前的话,其实应该也可以排除靠前的窗口,所以没有排除掉其实很奇怪.

blur完毕,生成texture,这个时候,依据alpha强度,在0.25以上的话,完全用blur替代,但是在以下的话,会变成alpha和blur的混合效果,依据alpha来调整效果比例.
然后,这里的两处alpha都不是全局性的,而是texture中的alpha频道,否则的话就无法处理不定型了.
由于是alpha频道,所以处理必然是交个了gl而不是c
也就是说,是gl计算出了融合所需要的alpha.
至少,在生成blur的时候,需要附加上窗口自身的alpha强度(然后乘以4?)

这里有一个问题是,窗口自身的背景是作为独立图层在后期与blur合并的,还是说一早
就融入到了blur算法中呢?

程序中有两个关键词,dst和src,是alpha算法相关的关键词.
source是新加入的,destination是已经存在的,所以source可以考虑作为前景,也就是窗口自身.
而destination就是背景了.

由于程序中出现了这两个词,所以很有可能,alpha算法是这个程序处理处理掉的,而不是交由外部.

2016-07-06 22:32:44 Wed NZST
因为进一步搞下去好像挺麻烦的,所以还是暂停吧.
现在的目标是,消除alpha和blur的耦合,以便把alpha降到0.25以下.
现在的进程是,从比较简易的srcFun入手,来检查,程序是如何把alpha混合到blur中的.
blur.c line 1056, srcFun很短,唯有的参数似乎只有一个0.25,虽然看似不怎么像.
检查这个数值需要重新编译compiz-core,不过我怕弄坏现有的compiz包,所以还是算了,
想要做这个测试,至少应该要在有备份恢复机制的情况下.

2016-07-07 02:21:21 Thu NZST
如此的话其实compiz比起compton的blur并不太好,果然后出的软件架构会更好.
但是compiz 的算法却是优化了很多的,估计是为了当时落后的硬件.结果是现在硬件更好之后,compiz的blur就可以使用比compton大的多的高斯半径了,到300似乎都没什么问题.
但是由于alpha和blur混合的原因,到300如果不降低alpha的话,会觉得效果比较差.所以只能用到150了.但是相比之下我记得compton的算法只能扩展到50-80,

从质地上来说,带有alpha的效果接近于磨砂玻璃.
完全消除alpha可以展现不一样的质地.

2016-07-07 09:54:57 Thu NZST
line 1332 分析

//output是dst的原有,sum是blur计算? sum*dst.a + output
//但是sum似乎没有blur效果.output也没有.两者独立都看不出效果.
//output是dst,sum是blur计算,mask来自output.a和env
//比较难以理解的是output.a
//output的最终输出是窗口北京,所以output.a太低的话,就会无法掩盖真实背景
//但是output.a不能乱设,无法单纯依赖它去改变透明度,会有异常效果.
//似乎是这样的,mask提供了整体的alpha,然后分成output和sum两份,
//在这里合并这两份,然后以mask的数值输出.
//纯sum的结果是,依旧会被25限制,同时窗口前景变淡了.
//也就是说,原本需要被mask掉不做blur的前景被牵扯了.
//纯output的结果是25以上,可以消除透明,背景色(白)相当于乘以了alpha.
//如此看来,25的问题或许不是这部分代码可以管理的?
//和mask有关吗?调整output.a的话,可以超出mask限制,但是会打破界面其他部分的约束?
似乎mask就是threshold.但是trheshhold似乎是int强转float,这种东西怎么可能作为alpha来用呢?

抓取的xgetwindowproperty propdata是,
_COMPIZ_WM_WINDOW_BLUR
看不出来这是什么.但是看来threshhold是外界定下来的.
0.25的限制可能是来自这里吗?感觉不太像.
取[0]位作为threshold

分析以下,纯output的结果.
output.a=mask,
dst.a=0
output.rgb=output.rgb
output.a=output.a=mask

_SAT是clip(0,1)的意思,所以mask 是env和output.a的乘积,并且在0,1之间.
当然,我们怀疑env把a收缩掉了.

纯output的情况下,为什么背景色会被alpha降低?
至少了解一点就是sum的确是blur,output则似乎是背景色,包括前景,包括alpha.
sum会占据掉output输出alpha不足的部分.与其融合得到新的颜色.

奇怪的地方是,如果alpha<0.25,不只是sum和output,原本的毕竟也会参与进来融合.

根据这部分代码来看,sum需要乘以dst.a才能加入output,所以output本身其实已经乘以过output.a了.

现在的问题是,当alpha很低的时候,当然output不会起作用,但是sum也不起效果.
解决办法是,把alpha拉高到0.25作为起点.
mask限定了总的alpha,然后output.a会在output和sum之间分配.
现在要想办法,把其看做0.25为起点,重新分配.
a2=a-0.25 / 0.75 
ouput=ouput/a * a2=output * (a-0.25)/0.75 *a
dst.a=mask -  (a-0.25)/0.75

麻烦的一点是,arb代码不知道在哪里出错.

总结一下,
纯blur的情况下,照理是要消除output的,不过我们没这么干,所以出现了模糊的前景.
纯output的情况下,blur被消除了,但是output自身需要重新调整恢复色彩.
纯output的情况下,如果alpha降到0.25以下,会出现透明,这个现象还不确定.
确认output.a可以直接设为1.0,掩盖掉其他东西.没有奇怪的颜色出现.
确认可以将output和sum的组合设为1.0,那么alpha为0的时候,blur也就有效了.

下面的问题是,如何给予特定部分的alpha为0?
现在的组合为1.0,但是显然mask的情况并非如此.实际上我们需要的是,拉高mask的阀值,把更多mask拉到1.0,但是要保留最小的部分
或许threshhold就是这么干的,alpha*4的话,那么0.25以上都会被拉高到1了.

猜中了,
所以threshold加到40的话,0,1,2以外的alpha都可以消除背景透明了.
这个threshold的源头似乎是 xprop的_COMPIZ_WM_WINDOW_BLUR属性,但是网上没有找到doc解释,所以不清楚是否所有window可以共享同一个数值.但是暂且这么做似乎也没什么问题.

2016-07-07 12:01:00 Thu NZST
大体来说,0 alpha和白色磨砂是材质.
不过0 allpha要求更大的blur半径,但是白色磨砂在大半径下的效果就不那么好了.
所以两者混用的话,其实还是最好还是能够区分窗口分配filter.

另外,单单一个材质的意义不大,组合分配材质的效果才会比较好,如果qtcurve能够像gtk一样区分布局分配材质就好了

不过我们倒是做第三个terminal来产生组合效果.
但是意义也不大,毕竟平时我几乎不会用blur的term.
唯有像是osx一样用在dock上,但是这个也是平常用不到的.
而rofi需要白色磨砂来提高对比度.

用在docky上对应到偏黑背景的时候,效果还是很明显的.

2016-07-07 12:17:02 Thu NZST
由于降低threshold降低造成的一个问题,
docky右键菜单有虚假阴影,被判别为blur了,不过提供全透明虚假阴影的软件也不多.
