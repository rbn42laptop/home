
     OldWinList已知的作用是保留原有的window顺序
     这个一维数组变量最主要在change_layout的时候起作用,旧有的窗口layout信息不再起效,而是以这个变量为准重排窗口.如果把这个变量改成tree的话,大概就可以做到和i3相近的事情了.
     TODO 希望和OldWinList作完全对比,推断是否有必要重绘layout,以及判断重绘的方式,比如如何插入新窗口或者删除旧窗口留下的空缺.
     一个问题是,move_window因为没有处理好细节,在移动的时候会造成可以累计下来的误差.最好是要有能力判断有新窗口开启,关闭,有窗口形状改变.这样的话,可以判断是否重载旧的layout,就不会造成误差累积了.比较明显的例子是在gnome-terminal和tilda混用的时候swap窗口.
     一个办法是,为所有winid,记录下stiler给予的xywh_defined,和最终被分配的xywh_actual,如果xywh_actual没有改变,就把xywh_defined当做layout来用
     TODO
     关于跨工作区记录的问题,unity7下,wmctrl给出的workspace编号并不准确,所以记录一个新的工作区有可能消去旧的工作区的layout信息.最好能用wmctrl意外的办法找出当前workspace编号,不过不知道跨DE是否兼容
    TODO strict 模式,i3的模式,在新建窗口,关闭窗口,resize,minimal,maximize窗口的时候,都会触发layout的调整.如果可以从WM监听到这些event,就可以实现
    lazy模式,每次调用layout命令的时候,对比旧有的window list,检查消失的,和新增的window,重新调整layout
    TODO 增删window的时候,layout中其他window的变动,参考下i3 的layout tree,大概就理解了.
    TODO tree 还是 list? 一般的tree layout,比如tmux,和其他的layout的形式是不兼容的.不过i3的tree只允许一个子节点,所以倒是可以类比的,但是i3似乎不允许grid,所以我们大概可以有多种mod,比如grid,horiz,vert这些list形式的,比如i3这样的单枝的tree,再比如一个完整的tree,一个完整的tree是最直观,i3为什么要那么设计呢?我猜是为了确保每一个指令都没有模糊化解释?
    TODO 和i3有关联的还有resize功能,这一点我倒是不怎么用,还有是i3可以选择新增窗口为col或者row,
    举例来说i3使用swap up命令的时候,可以选择与上方单元merge,也可以选择单纯与其交换,没有merge选项出现的话整体layout就不会改变
    TODO 关闭窗口暂且不论,可以控制新窗口打开时在tree上插入的位置,这一点如果不监控系统event的话,做起来就会比较繁琐,需要在新窗口打开后再敲重排layout的指令
    不过,排除这一点,仅仅实现tree layout以及merge功能也是很有吸引力的.
把这个模式和find nearest对比一下,find nearest实时的读取当前的layout在此基础上排布窗口,而tree layout显然是丢开现实,在tree的基础上做变动.
这带来的问题就是,find nearest在窗口位置改变后,仍然起作用,但是tree layout如果在layout改变之后,只有把改变后的layout再拖回旧的布局.要不然就是把改变的元素算作tree节点的增删

因此,在strict模式下,tree layout不用担心现实和model不符合,但是在更自由的环境下,就不的不考虑如何应对现实和model脱节的问题了.

--------------------------------------------------------------------------
如果我们不用tree模式,而在find nearest的基础上去实现swap merge呢?
那还有一个问题,就是添加新窗口的位置,还有多次 ctrl space调整layout的时候的问题.
不过tree layout如此多变,除非留存tree结构,否则也无法简单保留layout的,
显然整体调整layout并不是i3的方式,而是tmux的方式.而tmux是没有二维导航的,而一维的swap只是交换,没有merge的选项.但是tmux可以选择新建window的方式,因此可以创建不一样的layout.

如果我们不考虑strict模式的话.那么要想如同tmux,i3一样建立新的layout的话,就只能通过merge来做,毕竟new window在无监听的情况下实现的话,操作太烦锁了.

剩下的问题是,在find nearest的基础上做swap merge可能吗?
swap merge,第一要判断target和current属于同级,大体上可以构成一个矩形,第二,要判断所有与其它可能与其是同级的元素,然后在这些同级别之间重新分配面积.

其实这样子的话,我们的确需要tree,但是如果我们不用监听模式的话,我们可以直接通过像素把树画出来,根据屏幕上的像素分布,用矩形做划分.生成一棵tree,
这里有一个问题,就是碰到window重叠无法划分的情况下,要怎么办?
或许存在一些这样的算法?

下一个问题是,划分得到tree之后,current如何选择插入位置?
从实用的角度来说,如果原有的layout已经排布过了,那么重叠的可能性就很小了,但是新建的window很有可能会与其他window重叠,而上面处理tree重叠的算法很有可能是妥协的结果.

这里有一个办法,就是,简单的判断,如果current和其他窗体折叠,那么就取消其面积,不在计算tree的时候和merge的时候考虑进去,如果没折叠,那么就给它分配一定的空间.

所以核心问题就是,需要一个tree计算方案,即使是妥协的.

Fri 15 Apr 2016 17:35:34 NZST
delay
关于tree算法.大体思路来说,这是一个k-d tree,可以划分矩形,生成很多互不重叠的矩形.
我们的目标是,要求这些矩形能最大程度的去拟合现有的窗口layout.
那么具体来说需要怎样的拟合呢?
有很多不同的目标,
1比如按比例分配窗口的大小?这倒是不难.
2比如尽可能让窗口分配到的新位置与其原位置接近.或许最好是比例性质的接近,这个最好是按照center来计算而不是按照左上角来计算,不过只此一条,是否足够确保最大程度的拟合一个模糊的二维layout?这是需要深入考虑的问题,对于一个对人来说近似可划分但是实际上并不是的layout,用什么算法可以算出一个与人的期待一致的结果?
3还有比如不要影响到已经排布好的窗口的位置?这表明需要在模糊划分以前先做精确划分.对精确划分中无法划分的模块再做进一步处理.
4然后,也可以选择,在不触及无法划分的模块的时候,就不要去动它们.
5.即使做模糊划分的时候,是否有办法尽量少的变动窗口,尽可能保留大部分窗口不要变动.
还有是,即使触及了,是否可以不要全局性的对其做重排,而仅仅处理一小部分?
也就是说,极少变动原则

Fri 15 Apr 2016 17:52:41 NZST
solved
tree算法外的问题
6.说到尽量不要变动窗口的问题,由于wmctrl无法精确传达窗口大小,所以直接从屏幕上的矩形进行划分的话,可能会得到原本给予窗口的范围不同的数值.这导致,如果多次swap两个窗口的话,layout的数值会变动,也就是说,对于精确划分的结果,swap up swap down无法得到可逆的结果.
而可逆是很重要的.因此必须要对已有的精确划分做记录,并且要有机制判断这些精确划分没有被破坏,而不需要作出新的划分. 然后,最好wmctrl的不精确性不会导致一个预定义的单元被侵入.否则wmctrl的使用本身就会导致重新layout,这就很麻烦了.
solved
不过的确有侵入问题,有些窗口,wmctrl根本无权resize,这样的话,就会侵入到其周围的窗口.
但是考虑到这些窗口一般人不会希望以tiling的形式去用吧,这种侵入问题一般使用的时候不会发生的吧.我们需要做好得是,确保那些会用于tiling的,也就是wmctrl通常有权resize的窗口不要造成侵入问题.
7.重提一下上面的问题,就是对于current focus 的新窗口,如果重叠了,就不要给它分配空间.而作为一个完全新的单元融入tree中

Fri 15 Apr 2016 18:03:24 NZST
solved
tree算法之上,
1.如果我们有了一个大体的tree,那么,应该就能做到swap merge了,
2.insert new,根据新窗口的位置就可以算出来了.问题是,如果新窗口,不是一个,而是2个,3个呢?或者如果不是当前focus呢?不会不是当前focus,因为只有swap merge才能插入新窗口.麻烦的地方在于,用户可能开了一个新窗口放在那里,叠住了其他窗口,那么,在想要和其他窗口swap merge的时候,可能会撞上这些新窗口,不过这个,我觉得只能让用户自己负责了,
虽然直观上来说,会觉得,swap应该主要是在那些排布好的window之间进行的,最有可能成问题的是,在使用了一个叠加的firefox后,focus到layout上,而叠加掩盖了firefox,结果做swap的时候导致那个firefox影响到一整片布局,比较合理的想法是,最好把这个firefox考虑作为一个新插入的窗口?
我们的确可以做一个阀值限定,如果,swap的时候,所影响到的window中无法精确划分,并且没有,或者不符合旧有给予的layout的window的数目不超过比如5个,那么就把这些window算作待插入的tree的新窗口,这里的一个前提是预先给其余可划分的窗口做了layout记录,所谓layout记录,实质来说就是一个k-p tree
3.还有是resize功能,在tree之上做应该不会太难,如果影响到不可划分窗口,那么最好是忽略掉它们,嗯,比如说简单的收缩那些窗口
有了tree的话,剩下的就是这些功能,做起来应该不算复杂

Fri 15 Apr 2016 18:17:27 NZST
solved
大体来说,这样一个东西就完整了,只要有检查当前window layout的方法,和设定当前window layout的方法,那么不管linux,windows,osx的wm都是可以对接的,嗯,还有设定快捷键的自由

Fri 15 Apr 2016 18:24:25 NZST
solved
关于focus,tree的重排因为主要是swap的问题,关于focus的时候,用简单的find_nearest就行了,只要确保find_nearest在无重叠layout上找到的结果,和用tree兄弟节点找到的结果一样就可以了.
这说明我们放弃了对重叠layout进行swap的功能,不过感觉这没什么用处,毕竟我用tiling不多,但是用i3的就更不会有swap 重叠layout的了.

Fri 15 Apr 2016 18:28:55 NZST
solved
关于i3的floating 层,排除在layout以外的少量特殊窗口.
一方面,如果是专门的floating窗口,比如对话框之类的,应该可以根据窗口属性,直接从配置中排除掉.是否会有少量的情况下会想要同时维持一个floating的firefox和layout呢?这种情形很怪的吧,所以应该不会吧.

Fri 15 Apr 2016 18:38:43 NZST
delay
关于侵入计算.这个其实有点麻烦的,
因为要考虑到窗口resize后会形成新的layout,这里有个程序执行顺序问题,到底是是先算layout还是,先算侵入?
如果真的要实现的时候再考虑吧,这个问题算是和其他的独立的.

Fri 15 Apr 2016 18:22:14 NZST
总觉得还有什么想法没写下来?

Fri 15 Apr 2016 19:00:17 NZST
solved
按照以上方案来说,我们不会用监听方案,一是不需要绑定系统,二是显然这样更自由,这是我们放弃i3等strict模式的主要原因.
实际上我们选择模糊k-d tree的当下,就是选择了lazy模式.

roadmap
1.精确k-d tree
2.模糊k-d tree
3.划分记录window中的good child(沿用旧的layout) 和bad child(需要使用新的layout),

动机
我的确没什么动机去写一个tiling脚本，写程序的时候，其实一般三个或者四个窗口正好，而两个窗口的时候alt tab就够用了．
而且如果窗口更多，并且有重叠，这种时候其实focus比swap更好用，
其实写程序的时候最好用的layout应该是column2，宽度足够，又能均匀分配空间，按照屏幕空间来说的话，２－８个窗口应该是编码时候最常用的。这是我的习惯。
不过系统管理员什么的开ｃｏｎｋｙ或者音乐的人，似乎有着完全不同的习惯，他们使用ｖｉｍ　的方式也和我不同，会使用左侧栏文件列表之类的东西
所以说，这是别人的习惯，不是我的，就我的习惯而言，目前的代码已经很够用了（没有处理ｍｉｎｉｍｉｚｅｄ窗口是一个缺陷）
因此目前来说，我们没有实现一个ｋ－ｄ　ｔｒｅｅ算法的理由。
所以就到此为止了，把ｃｏｌｕｍｎ２　完善下就够了，
我想我们会需要一个偏左的，一个偏右的，还有有一个单列的，在ｒｏｔ　ｒｉｇｈｔ的时候会有用处，ｇｒｉｄ的那些，因为宽度不足，所以其实是没有用处的。
end

Sat 16 Apr 2016 00:06:02 NZST
一些bug
xdotool 和wmctrl有些时候会无法resize一些窗口，好像是那些被unity内置tiling 调整过的窗口
这是接口级别的问题，要么找到更好的接口，要么找出触发问题的原因，要么只能忽略

实验结果很明显，调用unity内置tiling之后，如果直接调用xdotool
就可以resize，但是如果改变windwo focus的话，就会resize失败。

Sat 16 Apr 2016 00:17:41 NZST
有的时候市面上有什么软件就只好用什么，毕竟自己写太浪费精力了，种种之前不需要关心的细节都会暴露出来。

Sat 16 Apr 2016 00:31:51 NZST
用空的话，录个gif视频，用几张默认壁纸，在3x3 workspace基础上，录个跨workspace的导航,视频上要配上按键字母，这个不知道要怎么做，去看看easymotion那边有没有什么办法
https://github.com/wavexx/screenkey
https://www.thregr.org/~wavexx/software/screenkey/
大概可以用这个软件
已知从直接从github下载即可使用，
我们要改下壁纸,至少传上github不能用现在的壁纸.还有找一个gif录像.所以还挺麻烦的。等下次showdesktop的时候再弄吧.
录之前尽量做好准备，不要录入多余的干扰按键像是rofi之类的，每个独立按键尽量提供足够的时间到它消失为止，尽量不要把多个按键混在一起，结尾用super+s展示下全局，我觉得弄个2X3的布局差不多
当然也可以弄个5x5的大布局效果明显些放到其他论坛上
为了表现出跨workspace不是调用了workspace机制，最好在workspace衔接处用col2的layout对应下左右，做个遍历
workspace之外，放几个可区分的window简单演示下swap，然后还有找个workspace开7个window,ctrl space layout,遍历一遍

或许放个跨workspace的窗口，效果会更好
演示的时候，或许用方向键替代hjkl会更好些，那么方向键也有必要加入readme的推荐按键

Sat 16 Apr 2016 10:45:40 NZST
git 录像
sudo apt-get install imagemagick mplayer gtk-recordmydesktop

gtk-recordmydesktop
On a terminal:
mplayer -ao null 1.mp4 -vo jpeg:outdir=output
Use ImageMagick to convert the screenshots into an animated gifs.
convert output/* output.gif

大致看了下，要高清兼时长是不可能,最好是用纯色背景，这样图片压缩效率也比较高，而且gif质量低下

这件事必须后延，不然你没法安心做其他事情了。
唯一可惜的是unity7很快要下市了
Sat 16 Apr 2016 11:37:07 NZST
一个问题，
现在有很多不同的layout，根据窗口数目来定的。如果说窗口数目变动的时候，该用哪个layout？
直觉化的来说，最好是先用原有的layout重新排列,然后再从layout list中遍历，
原有layout就在list中，那自然是最好的，如果不在其中呢？这也没办法咯,还是选择原有的才是理想的选择，所以每一个layout最好都可以处理所有可能的窗口数目，不要出error以备万一

Sat 16 Apr 2016 11:42:42 NZST
还有一点，因为现在没有计算workspace差异，所以没法为每个独立的workspace保存布局。

Sat 16 Apr 2016 11:49:43 NZST
关于compiz workspace的特殊构造
http://askubuntu.com/questions/41093/is-there-a-command-to-go-a-specific-workspace

Sat 16 Apr 2016 16:02:21 NZST
关于k-d tree 可以尝试实现一下，忽略掉有可能桌面layout很乱的事实，或者是如果桌面layout很乱就算作尝试tree转换失败。然后，转换成功的话，就可以基于这tree做focus，swap和resize操作了。由于wmctrl的非精确性，多次尝试tree转换可能会得到不同的结果造成layout出现轻微位移，最好是可以记录下layout，如果计算出的k-d tree依旧有效，就不要重新计算。
更准确的办法是，记录下分配给wmctrl的4维，和wmctrl实际得到的4维，然后对比检查变动是否产生。
反正是很麻烦的事情。
但是我只想简单的算个k-d tree

Sat 16 Apr 2016 16:17:58 NZST
http://stackoverflow.com/questions/2246150/minimizing-overlap-in-random-rectangles
这里有个问题，和我的问题很近，连overlap问题也包含了。不过答案只是简单的给了k d tree的wiki连接

我们需要的大概是这样的算法。我们选择纵向优先吧，因为我们使用col2最多，所以第一级分裂是纵向的。
第一步是纵向找出所有的可分割坐标，然后找出元素超过一个的叶子。
对这些叶子做横向分割。重复直到元素单一化，或者无法分割为止。非overlap的k d tree生成这么看来还是挺简单的。然后，如果操作过程中遇到不可分割元素呢？简单的做法，要么放弃，要么简单重排列，而不是用overlap tree算法。重排列什么的可以在swap出现的时候去做，k d tree自身不应该提供全局layout重排列，而且对于重复swap的窗口，第一次可以允许大小变动，但是之后最好能稳定下来。这个实验过之后就知道算法是否稳定了。

不稳定的地方在于，k d tree的分割缝隙不是唯一的，而是一个中值，所以wmctrl的微小变动，都会导致这个中值改变，这其实有可能导致一个窗口不断收缩或者扩大？不过我觉得我们可以选择扩大，扩大应该是有极限的，重复swap当前窗体占据周边的空隙，但是其他窗口的存在会提供一个这些空隙的极限。
按照这个方案来说，我们计算k d tree 的时候，需要记录空隙大小
总之这是个临时方案，完美方案是记录下wmctrl产生的误差，但那样需要记录很多跨进程变量，会很复杂

Sat 16 Apr 2016 19:10:55 NZST
扩展窗口的算法，存在着潜在的问题，就是同一条分割线，分割的不同列的窗口，分别有可能从左右侵入，这样就会导致这个分割先无效化了，幸运的是，每次分割，都会依据之前的侵入重新计算，所以侵入重叠的可能性还是比较小的。

这里，我们要考虑的问题，包括有resize和swap，
resize，实质上是调整一个节点后，重新平均分配兄弟节点，
而swap比较特殊，原则上是不会改变size的，
不过还有swap merge的情况，这和重新分配是有关联的。
resize 的时候，所有兄弟节点都会调整，swap merge的情况也是如此
而单纯的swap，则应该是不改变size，不过考虑这个也没有意义，因为swap merge的时候，是不存在单纯的swap的

Sat 16 Apr 2016 19:22:37 NZST
关于新窗口，虽然我们现在没有容忍overlap的能力，但是新窗口可以独立开来，先计算剩余部分的kdtree再按新窗口所在位置，在kdtree中查找位置
在实现这一点之前，这个功能只是可以用于排布好的空间的再构造，和resize

Sat 16 Apr 2016 19:27:07 NZST
wmctrl的容忍问题
最好是可以找出办法统一wmctrl的输入和输出，这样重复计算kdtree的时候误差才不会太大。

Sat 16 Apr 2016 19:30:57 NZST
关于tree swap，假设节点横向排列，横向swap会和旁边节点merge，再横向swap会走出，因此，横向排列走横向是构成子节点的意思，横向排列纵向，是成为父节点的意思

Sat 16 Apr 2016 21:53:01 NZST
虽然我们计算了tree，还算除了间隔大小，不过size或许还是以原窗口为准比较好，tree就作为keyset来用吧

Sat 16 Apr 2016 22:11:32 NZST
tree的问题，其实大体上来说，就是在一个给定的区域内，如何重绘layout
这需要照顾到各个window的原有尺寸比例，

Sat 16 Apr 2016 22:21:11 NZST
因为swap merge的存在，tree问题中resize太常见了，这就带来个问题，重叠部分怎么办？
老实说，或许只能硬性重排
要不然我们严格要求重排部分必须是无overlap的

Sat 16 Apr 2016 22:47:02 NZST
深入构造kdtree包含两方面，大概。
其实我们该从resize入手，这个其实比较简单的，swap将会是必然的包含resize的

Sun 17 Apr 2016 01:00:39 NZST
是否使用layout的间隙数据还是每次从windowborder读取？
最好是后者，因为前者可能会因为wmctrl的原因导致间隙变动

Sun 17 Apr 2016 01:14:20 NZST
gnome-terminal的一个问题，一次resize太小，比如font13的时候，改动5像素，是没有效果的。
改15都没效果
实际的解决方案是，不要使用表面的改动结果，而是要在后台记录下来，这样子，虽然少量的改动一开始不起效果，但是可以逐步累加。
简单的方案则是简单增大改动的大小，确保resize会生效
已知20可以起效。

Sun 17 Apr 2016 04:21:43 NZST
应该说是一个设计的问题，就是，
xx
xx 做swap right，会得到
x
xxx
然后下一次会被认作是 三列，这个时候，如果做 swap up就变成
x
x
xx
反正就是很怪的比例，
这终究来说，是因为我们从表面解析k d tree，而不是用隐藏变量来记录造成的？

Sun 17 Apr 2016 10:46:53 NZST
还有一点，i3是单一枝树，所以swap merge的操作中的merge减少了

Sun 17 Apr 2016 14:32:36 NZST
配合gnome terminal这样不能精确布局的窗口，多用几次swap resize就会导致布局变得很差，但是配合sakura，tilda，firefox，nautilus这样可以精确布局的问题就不会很大

Sun 17 Apr 2016 14:38:12 NZST
TODO 需要一个添加新窗口到 k-d tree的办法，查找节点

Sun 17 Apr 2016 14:39:13 NZST
对于sakura来说，好像也不能保证size和size_sum相等
所以无法记录child的resize
tilda也是一样
我想原因是border计算出问题了，所以无法还原 size 和size_sum了。
我们需要知道的是，一个上层给的size，和下层不符合，到底是因为上层真的改变了，还是说下层计算错误呢
结果只是一个bug

但是sakura连 vim标题也不显示，很不方便啊

Sun 17 Apr 2016 15:23:41 NZST
结果觉得t-d tree不怎么好用，resize功能因为wmctrl的原因很不流畅
而move node感觉没有swap直观。简单的窗口布局，我用swap都顺手了。当然swap弄不出新布局。
不过resize多少还是有点用处，但是resize较难配合gnome terminal用


Sun 17 Apr 2016 15:48:25 NZST
TODO
1.k-d tree中查找节点，添加新窗口
2.为gnome-terminal调整下算法，现在的情况，每次wmctrl调整都会导致gnome-termianl缩小，最好是在root节点，限定整体window大小，但是这个计算一定要足够准确，以免影响到其他程序
3.整理代码，命名和注释什么的,这个最优先，我自己都快看不懂代码了

总的来说，自用的话，这些需要吗？

TODO 2 ，通过在第一次k-d tree生成的时候记录 max height width，实现，这些数据会在之后重载到root node，regularize的时候，屏幕的整体大小就会传播下去了。
不过height width总有要变动的时候，
是否根据layout变动重置呢？但是如果最初的窗口没有占据全屏的话，高宽的数值就不对了，比如说跨workspace的时候，最好还是永久记录下来，然后按大小比对判断是否重置
按照现在的大小比对方案，就是只允许屏幕放大，不能缩小。否则会出问题
另一个严重的问题是，从 root node 获得的数据，有可能会超出屏幕整体大小啊。如果说窗口向屏幕外延伸了的话呢？
不过这些问题太超出了，因为一般来说调用k-d tree都是在重排layout之后的事情

Tue 19 Apr 2016 11:47:30 NZST
unity8出来后，或许可以把stiler改成触屏的？

Tue 19 Apr 2016 12:39:24 NZST
关于insert
有两个可选，一是按照窗体所在位置插入树中，
二是按照前一个focus所在位置插入树中。
第一个其实感觉更合理，但是第二个却是更符合流程的，因为要按照位置插入树，前提是用鼠标移动窗口到了合适的位置。

但是这里我们考虑的都是开启新窗口的情况，
如果是就得layout的变动呢？如果是鼠标改变了旧的layout的布局呢？

如果有focus新窗口
我想我们需要一个标记，标记之前是否存在过一次change layout操作。
如果存在，我们可以把新窗口作为layout纳入。
如果不存在，我们尝试用kd tree的形式纳入
如果纳入失败，我们再转换layout。
如果没有新窗口，那么change layout只是change layout

再来一次，
change layout，

检查窗口数目
如果数目不变：
    检查overlap，
    如果ovelap
        current layout
    else
        next layout
else：
    去除当前focus，作kdtree验证
    如果验证成功：
        作为kdtree处理,依据focus history查找最近的focus，添加新窗口位置
    else：
        作为current layout处理

再来一次
可能的情形包括
窗口数目是否改变，增多 减少。
是否出现overlap，overlap是否是focus

1.数目不变，overlap，先尝试focus kdtree，失败，那么current
2.数目不变，没有overlap，next layout
3.数目改变，overlap，先尝试focus kdtree，失败，current
4.数目改变，没有overlap，用kdtree layout ？current layout，

所以，没有overlap，就不尝试 kdtree插入了？那么新窗口恰好占了旧窗口的位置，但是排布漏出很多空隙怎么办呢？

情形2不能用kdtree layout，因为会妨碍到layout循环，
情形4倒是可以用，这样就替代了current layout了

Tue 19 Apr 2016 13:34:17 NZST
todo,那desktop坐标直接用来作为desktop标记吧。

因此，总结
1.数目不变，overlap，focus kdtree， current
2.数目改变，overlap，focuskdtree，current
3.数目不变，没有overlap，next layout
4.数目改变，没有 overlap，kdtree layout

也就是说，如果overlap出现，就是调用 kdtree focus，或者是current，
如果没出现，切数目不变，那么就按照原本的chagne layout模式运作。
如果数目变动，那么使用kd treelayout 修整

这些情形中，开新窗口，一般会导致overlap
关窗口则不会，
开关窗口，可以做到数目不改变，可能会有overlap
还有窗口移动，也有可能导致overlap，

因为关窗口导致的修整，其实最好是交给current layout来处理，
而开新窗口，但是没有出现overlap，这种很少的情形西湖可以交给kdtree？
新窗口 overlap，那么交给kdtreefocus比较好。
窗口移动的overlap，kdtreefocus或许可以尝试处理？

因此条件4应该拆分为窗口增多很减少两种情况？

1.数目不变，overlap，focus kdtree， current
2.数目改变，overlap，focuskdtree，current
3.数目不变，没有overlap，next layout
4.数目增多，没有 overlap，kdtree layout
5.数目减少，没有 overlap，current
if overlap 并且不是原本overlap的layout 比如 max:
    try:
        focus kdtree
    else:
        current
else:
    if =num:
        next 
    elif >num:
        kdtree
    elif <num:
        current
但是maximize的怎么算？
情形4还是算作current比较好吧？

Tue 19 Apr 2016 17:03:33 NZST
剧本，
super s
开窗口，平铺，resize
换工作区
开窗口平铺，move，
换回去
super s


Sat 30 Apr 2016 01:34:06 NZST
关于模糊kdtree,
可以用这样子的算法:以横向分割为例,找出一条分割线,
使得分割之后出现的跨界窗口面积最小,
同时做横竖处理,挑选出分割面积最小的.

这个功能可以暂且加给layout next, 如果有overlap存在,就尝试用这个办法对窗口进行kdtree重排.
极端情况下,这个方法会和 min window size 限制冲突,这个暂时不考虑.因为极端情况很少.

我想,仅仅加给 layout next是最好的选择,而在其他overlap的情况下,可以维持仅仅resize,或者move window.相当于保留两个选项,因为只有有必要的时候,才需要重排 kdtree layout.

但是这减少了第三个选项,就是仅仅在swap遇到障碍的时候,才重排某一个小区域.

但是这个也不是问题,可以这样子,如果当前focus overlap,那么就重排当前focus的部分.
否则,如果全局overlap,重排全局.
最后再是原有的layout next.

小片区域的overlap其实很少见,因为毕竟我们的屏幕太小了,窗口也就那点数目


Mon 02 May 2016 14:08:47 NZST
如果我们想要发布的话，
需要做的，除了打包成系统命令以外，就是加入一个按键设定界面，以及初始化dconf
https://developer.ubuntu.com/en/snappy/build-apps/
https://developer.ubuntu.com/en/snappy/build-apps/your-first-snap/

除了config以外
可以做一个弹窗界面，来排除部分app不加入layout，

Tue 03 May 2016 13:31:33 NZST
git 使用的时候，好像有3个状态比较方便？
因为改了一个文件就可以add，而不用马上commit
