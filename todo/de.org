* gnome3
** apps
   Mon 13 Jun 2016 03:17:59 PM NZST
 gnome3的布局虽然不喜欢，但是gnome3的app还挺不错的。
 不过问题是,这些app在compiz下和tile整合不好,因为似乎为了预留resize的边框,这些app在compiz下用了padding,也就是说在窗口布局的范围内还留出了视觉空隙,

 Mon 13 Jun 2016 03:19:58 PM NZST
 nautilus    文件管理
 evince      pdf
 baobab      磁盘空间
 eog         图片,不怎么用
 totem       视频,不怎么用
 gedit
 这些不带gnome前缀的大概都是精心设计过的.
 标题栏都被消除了.
 但是gimp的标题栏还在那里,看来不属于gnome核心
* tile
** root

      OldWinList已知的作用是保留原有的window顺序
      这个一维数组变量最主要在change_layout的时候起作用,旧有的窗口layout信息不再起效,而是以这个变量为准重排窗口.如果把这个变量改成tree的话,大概就可以做到和i3相近的事情了.
      TODO 希望和OldWinList作完全对比,推断是否有必要重绘layout,以及判断重绘的方式,比如如何插入新窗口或者删除旧窗口留下的空缺.
      一个问题是,move_window因为没有处理好细节,在移动的时候会造成可以累计下来的误差.最好是要有能力判断有新窗口开启,关闭,有窗口形状改变.这样的话,可以判断是否重载旧的layout,就不会造成误差累积了.比较明显的例子是在gnome-terminal和tilda混用的时候swap窗口.
      一个办法是,为所有winid,记录下stiler给予的xywh_defined,和最终被分配的xywh_actual,如果xywh_actual没有改变,就把xywh_defined当做layout来用
      TODO
      关于跨工作区记录的问题,unity7下,wmctrl给出的workspace编号并不准确,所以记录一个新的工作区有可能消去旧的工作区的layout信息.最好能用wmctrl意外的办法找出当前workspace编号,不过不知道跨DE是否兼容
     TODO strict 模式,i3的模式,在新建窗口,关闭窗口,resize,minimal,maximize窗口的时候,都会触发layout的调整.如果可以从WM监听到这些event,就可以实现
     lazy模式,每次调用layout命令的时候,对比旧有的window list,检查消失的,和新增的window,重新调整layout
     TODO 增删window的时候,layout中其他window的变动,参考下i3 的layout tree,大概就理解了.
     TODO tree 还是 list? 一般的tree layout,比如tmux,和其他的layout的形式是不兼容的.不过i3的tree只允许一个子节点,所以倒是可以类比的,但是i3似乎不允许grid,所以我们大概可以有多种mod,比如grid,horiz,vert这些list形式的,比如i3这样的单枝的tree,再比如一个完整的tree,一个完整的tree是最直观,i3为什么要那么设计呢?我猜是为了确保每一个指令都没有模糊化解释?
     TODO 和i3有关联的还有resize功能,这一点我倒是不怎么用,还有是i3可以选择新增窗口为col或者row,
     举例来说i3使用swap up命令的时候,可以选择与上方单元merge,也可以选择单纯与其交换,没有merge选项出现的话整体layout就不会改变
     TODO 关闭窗口暂且不论,可以控制新窗口打开时在tree上插入的位置,这一点如果不监控系统event的话,做起来就会比较繁琐,需要在新窗口打开后再敲重排layout的指令
     不过,排除这一点,仅仅实现tree layout以及merge功能也是很有吸引力的.
 把这个模式和find nearest对比一下,find nearest实时的读取当前的layout在此基础上排布窗口,而tree layout显然是丢开现实,在tree的基础上做变动.
 这带来的问题就是,find nearest在窗口位置改变后,仍然起作用,但是tree layout如果在layout改变之后,只有把改变后的layout再拖回旧的布局.要不然就是把改变的元素算作tree节点的增删

 因此,在strict模式下,tree layout不用担心现实和model不符合,但是在更自由的环境下,就不的不考虑如何应对现实和model脱节的问题了.

 --------------------------------------------------------------------------
 如果我们不用tree模式,而在find nearest的基础上去实现swap merge呢?
 那还有一个问题,就是添加新窗口的位置,还有多次 ctrl space调整layout的时候的问题.
 不过tree layout如此多变,除非留存tree结构,否则也无法简单保留layout的,
 显然整体调整layout并不是i3的方式,而是tmux的方式.而tmux是没有二维导航的,而一维的swap只是交换,没有merge的选项.但是tmux可以选择新建window的方式,因此可以创建不一样的layout.

 如果我们不考虑strict模式的话.那么要想如同tmux,i3一样建立新的layout的话,就只能通过merge来做,毕竟new window在无监听的情况下实现的话,操作太烦锁了.

 剩下的问题是,在find nearest的基础上做swap merge可能吗?
 swap merge,第一要判断target和current属于同级,大体上可以构成一个矩形,第二,要判断所有与其它可能与其是同级的元素,然后在这些同级别之间重新分配面积.

 其实这样子的话,我们的确需要tree,但是如果我们不用监听模式的话,我们可以直接通过像素把树画出来,根据屏幕上的像素分布,用矩形做划分.生成一棵tree,
 这里有一个问题,就是碰到window重叠无法划分的情况下,要怎么办?
 或许存在一些这样的算法?

 下一个问题是,划分得到tree之后,current如何选择插入位置?
 从实用的角度来说,如果原有的layout已经排布过了,那么重叠的可能性就很小了,但是新建的window很有可能会与其他window重叠,而上面处理tree重叠的算法很有可能是妥协的结果.

 这里有一个办法,就是,简单的判断,如果current和其他窗体折叠,那么就取消其面积,不在计算tree的时候和merge的时候考虑进去,如果没折叠,那么就给它分配一定的空间.

 所以核心问题就是,需要一个tree计算方案,即使是妥协的.

 Fri 15 Apr 2016 17:35:34 NZST
 delay
 关于tree算法.大体思路来说,这是一个k-d tree,可以划分矩形,生成很多互不重叠的矩形.
 我们的目标是,要求这些矩形能最大程度的去拟合现有的窗口layout.
 那么具体来说需要怎样的拟合呢?
 有很多不同的目标,
 1比如按比例分配窗口的大小?这倒是不难.
 2比如尽可能让窗口分配到的新位置与其原位置接近.或许最好是比例性质的接近,这个最好是按照center来计算而不是按照左上角来计算,不过只此一条,是否足够确保最大程度的拟合一个模糊的二维layout?这是需要深入考虑的问题,对于一个对人来说近似可划分但是实际上并不是的layout,用什么算法可以算出一个与人的期待一致的结果?
 3还有比如不要影响到已经排布好的窗口的位置?这表明需要在模糊划分以前先做精确划分.对精确划分中无法划分的模块再做进一步处理.
 4然后,也可以选择,在不触及无法划分的模块的时候,就不要去动它们.
 5.即使做模糊划分的时候,是否有办法尽量少的变动窗口,尽可能保留大部分窗口不要变动.
 还有是,即使触及了,是否可以不要全局性的对其做重排,而仅仅处理一小部分?
 也就是说,极少变动原则

 Fri 15 Apr 2016 17:52:41 NZST
 solved
 tree算法外的问题
 6.说到尽量不要变动窗口的问题,由于wmctrl无法精确传达窗口大小,所以直接从屏幕上的矩形进行划分的话,可能会得到原本给予窗口的范围不同的数值.这导致,如果多次swap两个窗口的话,layout的数值会变动,也就是说,对于精确划分的结果,swap up swap down无法得到可逆的结果.
 而可逆是很重要的.因此必须要对已有的精确划分做记录,并且要有机制判断这些精确划分没有被破坏,而不需要作出新的划分. 然后,最好wmctrl的不精确性不会导致一个预定义的单元被侵入.否则wmctrl的使用本身就会导致重新layout,这就很麻烦了.
 solved
 不过的确有侵入问题,有些窗口,wmctrl根本无权resize,这样的话,就会侵入到其周围的窗口.
 但是考虑到这些窗口一般人不会希望以tiling的形式去用吧,这种侵入问题一般使用的时候不会发生的吧.我们需要做好得是,确保那些会用于tiling的,也就是wmctrl通常有权resize的窗口不要造成侵入问题.
 7.重提一下上面的问题,就是对于current focus 的新窗口,如果重叠了,就不要给它分配空间.而作为一个完全新的单元融入tree中

 Fri 15 Apr 2016 18:03:24 NZST
 solved
 tree算法之上,
 1.如果我们有了一个大体的tree,那么,应该就能做到swap merge了,
 2.insert new,根据新窗口的位置就可以算出来了.问题是,如果新窗口,不是一个,而是2个,3个呢?或者如果不是当前focus呢?不会不是当前focus,因为只有swap merge才能插入新窗口.麻烦的地方在于,用户可能开了一个新窗口放在那里,叠住了其他窗口,那么,在想要和其他窗口swap merge的时候,可能会撞上这些新窗口,不过这个,我觉得只能让用户自己负责了,
 虽然直观上来说,会觉得,swap应该主要是在那些排布好的window之间进行的,最有可能成问题的是,在使用了一个叠加的firefox后,focus到layout上,而叠加掩盖了firefox,结果做swap的时候导致那个firefox影响到一整片布局,比较合理的想法是,最好把这个firefox考虑作为一个新插入的窗口?
 我们的确可以做一个阀值限定,如果,swap的时候,所影响到的window中无法精确划分,并且没有,或者不符合旧有给予的layout的window的数目不超过比如5个,那么就把这些window算作待插入的tree的新窗口,这里的一个前提是预先给其余可划分的窗口做了layout记录,所谓layout记录,实质来说就是一个k-p tree
 3.还有是resize功能,在tree之上做应该不会太难,如果影响到不可划分窗口,那么最好是忽略掉它们,嗯,比如说简单的收缩那些窗口
 有了tree的话,剩下的就是这些功能,做起来应该不算复杂

 Fri 15 Apr 2016 18:17:27 NZST
 solved
 大体来说,这样一个东西就完整了,只要有检查当前window layout的方法,和设定当前window layout的方法,那么不管linux,windows,osx的wm都是可以对接的,嗯,还有设定快捷键的自由

 Fri 15 Apr 2016 18:24:25 NZST
 solved
 关于focus,tree的重排因为主要是swap的问题,关于focus的时候,用简单的find_nearest就行了,只要确保find_nearest在无重叠layout上找到的结果,和用tree兄弟节点找到的结果一样就可以了.
 这说明我们放弃了对重叠layout进行swap的功能,不过感觉这没什么用处,毕竟我用tiling不多,但是用i3的就更不会有swap 重叠layout的了.

 Fri 15 Apr 2016 18:28:55 NZST
 solved
 关于i3的floating 层,排除在layout以外的少量特殊窗口.
 一方面,如果是专门的floating窗口,比如对话框之类的,应该可以根据窗口属性,直接从配置中排除掉.是否会有少量的情况下会想要同时维持一个floating的firefox和layout呢?这种情形很怪的吧,所以应该不会吧.

 Fri 15 Apr 2016 18:38:43 NZST
 delay
 关于侵入计算.这个其实有点麻烦的,
 因为要考虑到窗口resize后会形成新的layout,这里有个程序执行顺序问题,到底是是先算layout还是,先算侵入?
 如果真的要实现的时候再考虑吧,这个问题算是和其他的独立的.

 Fri 15 Apr 2016 18:22:14 NZST
 总觉得还有什么想法没写下来?

 Fri 15 Apr 2016 19:00:17 NZST
 solved
 按照以上方案来说,我们不会用监听方案,一是不需要绑定系统,二是显然这样更自由,这是我们放弃i3等strict模式的主要原因.
 实际上我们选择模糊k-d tree的当下,就是选择了lazy模式.

 roadmap
 1.精确k-d tree
 2.模糊k-d tree
 3.划分记录window中的good child(沿用旧的layout) 和bad child(需要使用新的layout),

 动机
 我的确没什么动机去写一个tiling脚本，写程序的时候，其实一般三个或者四个窗口正好，而两个窗口的时候alt tab就够用了．
 而且如果窗口更多，并且有重叠，这种时候其实focus比swap更好用，
 其实写程序的时候最好用的layout应该是column2，宽度足够，又能均匀分配空间，按照屏幕空间来说的话，２－８个窗口应该是编码时候最常用的。这是我的习惯。
 不过系统管理员什么的开ｃｏｎｋｙ或者音乐的人，似乎有着完全不同的习惯，他们使用ｖｉｍ　的方式也和我不同，会使用左侧栏文件列表之类的东西
 所以说，这是别人的习惯，不是我的，就我的习惯而言，目前的代码已经很够用了（没有处理ｍｉｎｉｍｉｚｅｄ窗口是一个缺陷）
 因此目前来说，我们没有实现一个ｋ－ｄ　ｔｒｅｅ算法的理由。
 所以就到此为止了，把ｃｏｌｕｍｎ２　完善下就够了，
 我想我们会需要一个偏左的，一个偏右的，还有有一个单列的，在ｒｏｔ　ｒｉｇｈｔ的时候会有用处，ｇｒｉｄ的那些，因为宽度不足，所以其实是没有用处的。
 end

 Sat 16 Apr 2016 00:06:02 NZST
 一些bug
 xdotool 和wmctrl有些时候会无法resize一些窗口，好像是那些被unity内置tiling 调整过的窗口
 这是接口级别的问题，要么找到更好的接口，要么找出触发问题的原因，要么只能忽略

 实验结果很明显，调用unity内置tiling之后，如果直接调用xdotool
 就可以resize，但是如果改变windwo focus的话，就会resize失败。

 Sat 16 Apr 2016 00:17:41 NZST
 有的时候市面上有什么软件就只好用什么，毕竟自己写太浪费精力了，种种之前不需要关心的细节都会暴露出来。

 Sat 16 Apr 2016 00:31:51 NZST
 用空的话，录个gif视频，用几张默认壁纸，在3x3 workspace基础上，录个跨workspace的导航,视频上要配上按键字母，这个不知道要怎么做，去看看easymotion那边有没有什么办法
 https://github.com/wavexx/screenkey
 https://www.thregr.org/~wavexx/software/screenkey/
 大概可以用这个软件
 已知从直接从github下载即可使用，
 我们要改下壁纸,至少传上github不能用现在的壁纸.还有找一个gif录像.所以还挺麻烦的。等下次showdesktop的时候再弄吧.
 录之前尽量做好准备，不要录入多余的干扰按键像是rofi之类的，每个独立按键尽量提供足够的时间到它消失为止，尽量不要把多个按键混在一起，结尾用super+s展示下全局，我觉得弄个2X3的布局差不多
 当然也可以弄个5x5的大布局效果明显些放到其他论坛上
 为了表现出跨workspace不是调用了workspace机制，最好在workspace衔接处用col2的layout对应下左右，做个遍历
 workspace之外，放几个可区分的window简单演示下swap，然后还有找个workspace开7个window,ctrl space layout,遍历一遍

 或许放个跨workspace的窗口，效果会更好
 演示的时候，或许用方向键替代hjkl会更好些，那么方向键也有必要加入readme的推荐按键

 Sat 16 Apr 2016 10:45:40 NZST
 git 录像
 sudo apt-get install imagemagick mplayer gtk-recordmydesktop

 gtk-recordmydesktop
 On a terminal:
 mplayer -ao null 1.mp4 -vo jpeg:outdir=output
 Use ImageMagick to convert the screenshots into an animated gifs.
 convert output/* output.gif

 大致看了下，要高清兼时长是不可能,最好是用纯色背景，这样图片压缩效率也比较高，而且gif质量低下

 这件事必须后延，不然你没法安心做其他事情了。
 唯一可惜的是unity7很快要下市了
 Sat 16 Apr 2016 11:37:07 NZST
 一个问题，
 现在有很多不同的layout，根据窗口数目来定的。如果说窗口数目变动的时候，该用哪个layout？
 直觉化的来说，最好是先用原有的layout重新排列,然后再从layout list中遍历，
 原有layout就在list中，那自然是最好的，如果不在其中呢？这也没办法咯,还是选择原有的才是理想的选择，所以每一个layout最好都可以处理所有可能的窗口数目，不要出error以备万一

 Sat 16 Apr 2016 11:42:42 NZST
 还有一点，因为现在没有计算workspace差异，所以没法为每个独立的workspace保存布局。

 Sat 16 Apr 2016 11:49:43 NZST
 关于compiz workspace的特殊构造
 http://askubuntu.com/questions/41093/is-there-a-command-to-go-a-specific-workspace

 Sat 16 Apr 2016 16:02:21 NZST
 关于k-d tree 可以尝试实现一下，忽略掉有可能桌面layout很乱的事实，或者是如果桌面layout很乱就算作尝试tree转换失败。然后，转换成功的话，就可以基于这tree做focus，swap和resize操作了。由于wmctrl的非精确性，多次尝试tree转换可能会得到不同的结果造成layout出现轻微位移，最好是可以记录下layout，如果计算出的k-d tree依旧有效，就不要重新计算。
 更准确的办法是，记录下分配给wmctrl的4维，和wmctrl实际得到的4维，然后对比检查变动是否产生。
 反正是很麻烦的事情。
 但是我只想简单的算个k-d tree

 Sat 16 Apr 2016 16:17:58 NZST
 http://stackoverflow.com/questions/2246150/minimizing-overlap-in-random-rectangles
 这里有个问题，和我的问题很近，连overlap问题也包含了。不过答案只是简单的给了k d tree的wiki连接

 我们需要的大概是这样的算法。我们选择纵向优先吧，因为我们使用col2最多，所以第一级分裂是纵向的。
 第一步是纵向找出所有的可分割坐标，然后找出元素超过一个的叶子。
 对这些叶子做横向分割。重复直到元素单一化，或者无法分割为止。非overlap的k d tree生成这么看来还是挺简单的。然后，如果操作过程中遇到不可分割元素呢？简单的做法，要么放弃，要么简单重排列，而不是用overlap tree算法。重排列什么的可以在swap出现的时候去做，k d tree自身不应该提供全局layout重排列，而且对于重复swap的窗口，第一次可以允许大小变动，但是之后最好能稳定下来。这个实验过之后就知道算法是否稳定了。

 不稳定的地方在于，k d tree的分割缝隙不是唯一的，而是一个中值，所以wmctrl的微小变动，都会导致这个中值改变，这其实有可能导致一个窗口不断收缩或者扩大？不过我觉得我们可以选择扩大，扩大应该是有极限的，重复swap当前窗体占据周边的空隙，但是其他窗口的存在会提供一个这些空隙的极限。
 按照这个方案来说，我们计算k d tree 的时候，需要记录空隙大小
 总之这是个临时方案，完美方案是记录下wmctrl产生的误差，但那样需要记录很多跨进程变量，会很复杂

 Sat 16 Apr 2016 19:10:55 NZST
 扩展窗口的算法，存在着潜在的问题，就是同一条分割线，分割的不同列的窗口，分别有可能从左右侵入，这样就会导致这个分割先无效化了，幸运的是，每次分割，都会依据之前的侵入重新计算，所以侵入重叠的可能性还是比较小的。

 这里，我们要考虑的问题，包括有resize和swap，
 resize，实质上是调整一个节点后，重新平均分配兄弟节点，
 而swap比较特殊，原则上是不会改变size的，
 不过还有swap merge的情况，这和重新分配是有关联的。
 resize 的时候，所有兄弟节点都会调整，swap merge的情况也是如此
 而单纯的swap，则应该是不改变size，不过考虑这个也没有意义，因为swap merge的时候，是不存在单纯的swap的

 Sat 16 Apr 2016 19:22:37 NZST
 关于新窗口，虽然我们现在没有容忍overlap的能力，但是新窗口可以独立开来，先计算剩余部分的kdtree再按新窗口所在位置，在kdtree中查找位置
 在实现这一点之前，这个功能只是可以用于排布好的空间的再构造，和resize

 Sat 16 Apr 2016 19:27:07 NZST
 wmctrl的容忍问题
 最好是可以找出办法统一wmctrl的输入和输出，这样重复计算kdtree的时候误差才不会太大。

 Sat 16 Apr 2016 19:30:57 NZST
 关于tree swap，假设节点横向排列，横向swap会和旁边节点merge，再横向swap会走出，因此，横向排列走横向是构成子节点的意思，横向排列纵向，是成为父节点的意思

 Sat 16 Apr 2016 21:53:01 NZST
 虽然我们计算了tree，还算除了间隔大小，不过size或许还是以原窗口为准比较好，tree就作为keyset来用吧

 Sat 16 Apr 2016 22:11:32 NZST
 tree的问题，其实大体上来说，就是在一个给定的区域内，如何重绘layout
 这需要照顾到各个window的原有尺寸比例，

 Sat 16 Apr 2016 22:21:11 NZST
 因为swap merge的存在，tree问题中resize太常见了，这就带来个问题，重叠部分怎么办？
 老实说，或许只能硬性重排
 要不然我们严格要求重排部分必须是无overlap的

 Sat 16 Apr 2016 22:47:02 NZST
 深入构造kdtree包含两方面，大概。
 其实我们该从resize入手，这个其实比较简单的，swap将会是必然的包含resize的

 Sun 17 Apr 2016 01:00:39 NZST
 是否使用layout的间隙数据还是每次从windowborder读取？
 最好是后者，因为前者可能会因为wmctrl的原因导致间隙变动

 Sun 17 Apr 2016 01:14:20 NZST
 gnome-terminal的一个问题，一次resize太小，比如font13的时候，改动5像素，是没有效果的。
 改15都没效果
 实际的解决方案是，不要使用表面的改动结果，而是要在后台记录下来，这样子，虽然少量的改动一开始不起效果，但是可以逐步累加。
 简单的方案则是简单增大改动的大小，确保resize会生效
 已知20可以起效。

 Sun 17 Apr 2016 04:21:43 NZST
 应该说是一个设计的问题，就是，
 xx
 xx 做swap right，会得到
 x
 xxx
 然后下一次会被认作是 三列，这个时候，如果做 swap up就变成
 x
 x
 xx
 反正就是很怪的比例，
 这终究来说，是因为我们从表面解析k d tree，而不是用隐藏变量来记录造成的？

 Sun 17 Apr 2016 10:46:53 NZST
 还有一点，i3是单一枝树，所以swap merge的操作中的merge减少了

 Sun 17 Apr 2016 14:32:36 NZST
 配合gnome terminal这样不能精确布局的窗口，多用几次swap resize就会导致布局变得很差，但是配合sakura，tilda，firefox，nautilus这样可以精确布局的问题就不会很大

 Sun 17 Apr 2016 14:38:12 NZST
 TODO 需要一个添加新窗口到 k-d tree的办法，查找节点

 Sun 17 Apr 2016 14:39:13 NZST
 对于sakura来说，好像也不能保证size和size_sum相等
 所以无法记录child的resize
 tilda也是一样
 我想原因是border计算出问题了，所以无法还原 size 和size_sum了。
 我们需要知道的是，一个上层给的size，和下层不符合，到底是因为上层真的改变了，还是说下层计算错误呢
 结果只是一个bug

 但是sakura连 vim标题也不显示，很不方便啊

 Sun 17 Apr 2016 15:23:41 NZST
 结果觉得t-d tree不怎么好用，resize功能因为wmctrl的原因很不流畅
 而move node感觉没有swap直观。简单的窗口布局，我用swap都顺手了。当然swap弄不出新布局。
 不过resize多少还是有点用处，但是resize较难配合gnome terminal用


 Sun 17 Apr 2016 15:48:25 NZST
 TODO
 1.k-d tree中查找节点，添加新窗口
 2.为gnome-terminal调整下算法，现在的情况，每次wmctrl调整都会导致gnome-termianl缩小，最好是在root节点，限定整体window大小，但是这个计算一定要足够准确，以免影响到其他程序
 3.整理代码，命名和注释什么的,这个最优先，我自己都快看不懂代码了

 总的来说，自用的话，这些需要吗？

 TODO 2 ，通过在第一次k-d tree生成的时候记录 max height width，实现，这些数据会在之后重载到root node，regularize的时候，屏幕的整体大小就会传播下去了。
 不过height width总有要变动的时候，
 是否根据layout变动重置呢？但是如果最初的窗口没有占据全屏的话，高宽的数值就不对了，比如说跨workspace的时候，最好还是永久记录下来，然后按大小比对判断是否重置
 按照现在的大小比对方案，就是只允许屏幕放大，不能缩小。否则会出问题
 另一个严重的问题是，从 root node 获得的数据，有可能会超出屏幕整体大小啊。如果说窗口向屏幕外延伸了的话呢？
 不过这些问题太超出了，因为一般来说调用k-d tree都是在重排layout之后的事情

 Tue 19 Apr 2016 11:47:30 NZST
 unity8出来后，或许可以把stiler改成触屏的？

 Tue 19 Apr 2016 12:39:24 NZST
 关于insert
 有两个可选，一是按照窗体所在位置插入树中，
 二是按照前一个focus所在位置插入树中。
 第一个其实感觉更合理，但是第二个却是更符合流程的，因为要按照位置插入树，前提是用鼠标移动窗口到了合适的位置。

 但是这里我们考虑的都是开启新窗口的情况，
 如果是就得layout的变动呢？如果是鼠标改变了旧的layout的布局呢？

 如果有focus新窗口
 我想我们需要一个标记，标记之前是否存在过一次change layout操作。
 如果存在，我们可以把新窗口作为layout纳入。
 如果不存在，我们尝试用kd tree的形式纳入
 如果纳入失败，我们再转换layout。
 如果没有新窗口，那么change layout只是change layout

 再来一次，
 change layout，

 检查窗口数目
 如果数目不变：
     检查overlap，
     如果ovelap
         current layout
     else
         next layout
 else：
     去除当前focus，作kdtree验证
     如果验证成功：
         作为kdtree处理,依据focus history查找最近的focus，添加新窗口位置
     else：
         作为current layout处理

 再来一次
 可能的情形包括
 窗口数目是否改变，增多 减少。
 是否出现overlap，overlap是否是focus

 1.数目不变，overlap，先尝试focus kdtree，失败，那么current
 2.数目不变，没有overlap，next layout
 3.数目改变，overlap，先尝试focus kdtree，失败，current
 4.数目改变，没有overlap，用kdtree layout ？current layout，

 所以，没有overlap，就不尝试 kdtree插入了？那么新窗口恰好占了旧窗口的位置，但是排布漏出很多空隙怎么办呢？

 情形2不能用kdtree layout，因为会妨碍到layout循环，
 情形4倒是可以用，这样就替代了current layout了

 Tue 19 Apr 2016 13:34:17 NZST
 todo,那desktop坐标直接用来作为desktop标记吧。

 因此，总结
 1.数目不变，overlap，focus kdtree， current
 2.数目改变，overlap，focuskdtree，current
 3.数目不变，没有overlap，next layout
 4.数目改变，没有 overlap，kdtree layout

 也就是说，如果overlap出现，就是调用 kdtree focus，或者是current，
 如果没出现，切数目不变，那么就按照原本的chagne layout模式运作。
 如果数目变动，那么使用kd treelayout 修整

 这些情形中，开新窗口，一般会导致overlap
 关窗口则不会，
 开关窗口，可以做到数目不改变，可能会有overlap
 还有窗口移动，也有可能导致overlap，

 因为关窗口导致的修整，其实最好是交给current layout来处理，
 而开新窗口，但是没有出现overlap，这种很少的情形西湖可以交给kdtree？
 新窗口 overlap，那么交给kdtreefocus比较好。
 窗口移动的overlap，kdtreefocus或许可以尝试处理？

 因此条件4应该拆分为窗口增多很减少两种情况？

 1.数目不变，overlap，focus kdtree， current
 2.数目改变，overlap，focuskdtree，current
 3.数目不变，没有overlap，next layout
 4.数目增多，没有 overlap，kdtree layout
 5.数目减少，没有 overlap，current
 if overlap 并且不是原本overlap的layout 比如 max:
     try:
         focus kdtree
     else:
         current
 else:
     if =num:
         next 
     elif >num:
         kdtree
     elif <num:
         current
 但是maximize的怎么算？
 情形4还是算作current比较好吧？

 Tue 19 Apr 2016 17:03:33 NZST
 剧本，
 super s
 开窗口，平铺，resize
 换工作区
 开窗口平铺，move，
 换回去
 super s


 Sat 30 Apr 2016 01:34:06 NZST
 关于模糊kdtree,
 可以用这样子的算法:以横向分割为例,找出一条分割线,
 使得分割之后出现的跨界窗口面积最小,
 同时做横竖处理,挑选出分割面积最小的.

 这个功能可以暂且加给layout next, 如果有overlap存在,就尝试用这个办法对窗口进行kdtree重排.
 极端情况下,这个方法会和 min window size 限制冲突,这个暂时不考虑.因为极端情况很少.

 我想,仅仅加给 layout next是最好的选择,而在其他overlap的情况下,可以维持仅仅resize,或者move window.相当于保留两个选项,因为只有有必要的时候,才需要重排 kdtree layout.

 但是这减少了第三个选项,就是仅仅在swap遇到障碍的时候,才重排某一个小区域.

 但是这个也不是问题,可以这样子,如果当前focus overlap,那么就重排当前focus的部分.
 否则,如果全局overlap,重排全局.
 最后再是原有的layout next.

 小片区域的overlap其实很少见,因为毕竟我们的屏幕太小了,窗口也就那点数目


 Mon 02 May 2016 14:08:47 NZST
 如果我们想要发布的话，
 需要做的，除了打包成系统命令以外，就是加入一个按键设定界面，以及初始化dconf
 https://developer.ubuntu.com/en/snappy/build-apps/
 https://developer.ubuntu.com/en/snappy/build-apps/your-first-snap/

 除了config以外
 可以做一个弹窗界面，来排除部分app不加入layout，

 Tue 03 May 2016 13:31:33 NZST
 git 使用的时候，好像有3个状态比较方便？
 因为改了一个文件就可以add，而不用马上commit

 Thu 23 Jun 2016 11:10:04 PM NZST
 似乎wmutils的热点很高,如果将来把底层转换到wmutils的话,或许可以同时支持wayland和x了.
 但是wayland还没有expo,所以支持wayland暂时对我没什么用处.

 Fri 01 Jul 2016 10:08:31 PM NZST
 i4 a window tiling script forks i3

 转移到wmutils的好处,
 1.因为是专注wm的,而不是测试的,所以性能提升?
 2.wayland迁移
 3.跨de兼容性,在unity7,要求窗体有一定margin才能保证没有overlap,在compiz0.8,给予的x,y的数值是正常数值的两倍.这些问题wmutils是否能帮忙处理掉呢?

 不过好像wmutils实现的功能并不是那么多,一个工具不足以解决问题,还是需要和其他工具联合运作的.
 但是的确都是很精简的小工具,

 但是,准确的tile布局涉及到很细微的调整,当前为了计算出准确的xywh,写下了很复杂的代码.
 wmutils是否足够精确,我们并不知道

 2016-07-04 18:38:59 Mon NZST
 当前来说,focus有明显的性能问题,focus触发之后,一般会有一个按键事件被原窗口捕捉到.
 有时间的话,希望试试看换成wmutils会不会好些,毕竟这个是专门的wm工具,应该不会容忍这样的性能问题.

 2016-07-04 19:20:57 Mon NZST
 结果wmutils的性能并不会提升.

 2016-07-21 17:38:49 Thu NZST
 细节处理还有很多问题,尤其是引入regularize之后,细节不够精确似乎导致了regularize会覆盖重置一定的用户操作.
 代码结构也有点乱,如果能整理下头绪重构下代码就好了.

 现在还是觉的regularize会比layout next更顺手.
 也就是说,改变布局还是依赖move更多些,而不是layout next,
 layout next几乎是无法直接给出顺手的布局的,因为用户完全不知道潜在的窗口排序信息,所以无法预测layout next可以给出布局结果.
 对比来说,move能够给出的结果就很清晰了.

 如此的话,撇开layout next来看,这种方式就很接近i3了
 ,也就是说,预设布局可以在桌面上乱方了一堆窗口的时候,做出第一次整理,但是人会需要花一定时间去理解窗口的新布局.
 相比之下,move操作要理解起来就很容易了.
 所以layout操作的数目需要减少.
 这样的话,layout操作实际上就主要是起到regularize的作用了.
 对于i3来说 regularize是自动进行的.
 但是老实说,这样很不自由,这也是我不想用i3的原因.

 但是每次增减窗口都要regularize是否很麻烦呢?

 有没有更加折衷,保持自由度的同时,也不带来太多麻烦的方式呢?
 区分性的开启和关闭监听模式?

 2016-07-21 23:18:23 Thu NZST
 有想法的时候,最后能总结体系化,然后才能加入到master
 否则的话现有的想法可能是和之前的想法冲突的,没有原则.

* panel
** 位置
 Mon 13 Jun 2016 08:00:53 PM NZST
 panel的位置
 上端可以和titlebar共用空间,
 下端不行.
 titlebar按钮在右上角,所以panel放左上角
* start
** rofi 
Sat 28 May 2016 07:44:37 AM NZST
rofi是application menu的很好替代,可以在其中加入特殊化的常用命令,要在一般application menu加入就比较麻烦.
然后搜索历史命令又很便捷.

不过鼠标用就只能点选最长用的几个了.

所以,为了方便鼠标使用,如果可以加入树形菜单功能就好了.
不过平时鼠标用的不多,所以这不太重要

Tue 07 Jun 2016 01:27:40 PM NZST
rofi的一个问题,使用setofont的时候,有些条目的文字定位不准确导致文字现实不完全.
相关的原因是,这些条目中setofont不完整,需要从其他font抽取文字补充.

或许补充的font有问题,用seto和wqy做混合字体就把问题解决了

Tue 07 Jun 2016 01:42:03 PM NZST
其实作为一个start search来说,rofi还没做到极致,
图形方面来说的话,自然是图标什么的.
另一方面的问题是搜索域还可以扩大,加入搜索引擎之类的.
还有是文件搜索什么的,这也是搜索域的问题.

rofi的优势当然是独立,其他绝大部分的start search都是和de整合的,
好像有个slingshot很有名的样子,好像mac上也有类似的东西
mac上的是spotlight,替代品是synapse和mutate
搜索域包括app,dict和web(主要是google)
spotlight,作为原版,搜索域更大,还包括file和msg,doc,contact

其他的话,cinnamon,unity7,gnome3,kde,winxp,都是有start search的.

不过rofi这东西的确一般人不会去用,因为至少要有一点熟悉命令行,那么才能编写出自己的常用命令,才会需要去调用.
说到底这是键盘用户专用的.
对于普通用户来说,mac给他们准备了spotlight,所以主要还是以app搜索为主
另外file搜索准确度实在太低,还不如自己cd去找快些(很难比较cd和browser的速度差别)
所以还是自己把自己需要的常用文档记录在rofi中会比较方便


Tue 07 Jun 2016 07:28:43 PM NZST
rofi 没法用fcitx,ibus没有试.所以没法把web搜索引擎加入到rofi.
不过另一方面,firefox的右键关键词搜索也是整合浏览器的功能,没有办法向外移植的.

Tue 14 Jun 2016 01:10:44 PM NZST
其实rofi提供i3和dmenu接口,说明是有办法换一个ui整合rofi的.

Wed 29 Jun 2016 08:45:51 PM NZST
是否可以替代rofi呢?
其实仔细想想,rofi提供的history以外的搜索是很有限的,基本上只是bash的PATH环境而已.
对于常用软件来说没什么用处,有用处的场合是查找一些不常用的gnome xfce 的gui软件.
rofi 不便利的一点是鼠标操作很不友好.

不过简单的解决办法其实是把键盘鼠标的开始菜单分开设置.
但是这样的就无法共享hist了.
不过也没有问题,我们可以自己些一个鼠标的开始菜单,并且读取rofi的hist
** 搜索
Thu 09 Jun 2016 03:00:49 PM NZST
大概是这样的功能:
搜索字眼来自ctrl+c,不过也可以手动输入.
触发后(快捷键或者ctrl+c),可以选择搜索项目,以web引擎为主,也可加入dict和file
有点类似mac的spotlight

我的想法:
最近使用的一个搜索项,会放置到队列前,因为重复使用同一个搜索的情况很常见.

可能存在的多级操作:
第一,启动后,待输入关键词,待选择引擎,当让都有默认,然后确认开始搜索.
第二,启动后直接进行默认搜索,省去确认过程.

Thu 09 Jun 2016 03:07:56 PM NZST
要是能勾选关键词后,直接启动搜索,或许更方便,但是这种api很难处理吧.
所以为了api的处理简易,还是只能先复制,

Thu 09 Jun 2016 03:10:14 PM NZST
顺便,浏览器,和pdf,键盘操作不便的一点就是勾选关键词了,没有类似vim的方案.
firefox倒是有的,vimperator,但是平时用vimfx比它顺手,而且感觉前者bug多,但是触及太底层了吧.
* compiz
** 0.8
*** 性能
Wed 15 Jun 2016 12:48:13 AM NZST
有一点感觉挺不错的.
在我之前配合qmlterm和其他窗口共用的时候,用tile转移focus感觉效率不对劲.
而在qmlterm内部转移则没问题.

这个问题在0.8中似乎感觉不到存在,focus转移很流畅


    Wed 15 Jun 2016 01:24:58 AM NZST
可以感觉到0.8的新更能较弱，比如expo，换wallpaper的cpu占用会比较高,速度比较慢
但是0.8似乎比0.9少了很多烦人的小bug
不过反正这台电脑本身就比较弱，将来有更好的电脑的时候，应该不会是问题


Wed 15 Jun 2016 05:46:26 PM NZST
workspace 5x5的时候,耳机会出现一定的电流声,是在消耗性能吧
*** wmctrl

现在看起来，wmctrl给出的数据大约是实际数据的两倍.
但是输出layout的时候,似乎还是准确的.
而且,不准确的仅仅是位置,高宽依旧没变
简单的把wmctrl -lG的xy信息除以2之后似乎就把问题解决了
*** wallpaper
Tue 14 Jun 2016 02:17:45 AM NZST
一个问题是wallpaper字段太长会被缩略，所以5×5的桌面就是极限了，更大的桌面难以塞入路径，除非我们想办法收缩路径
可以用shortcut

*** root
Mon 13 Jun 2016 09:44:35 PM NZST
关于blur
全透明的状态下，blur是无效的.

Mon 13 Jun 2016 11:06:46 PM NZST
或许我们该用compiz0.8，因为,comipz0.8没有丢失focus的问题,暂且也感觉不到稳定性的问题.
不过dconf接口就不能用了,而是要自己用python读写配置文件,这个会比较麻烦.而且不知道compiz会不会即时载入wallpaper

shortcut command支持数目也更多

不过感觉对xprop的支持有问题导致得到的tile得到的信息不准确
Tue 14 Jun 2016 12:26:08 AM NZST
expo 不支持分辨拖动和点击,所以不得不分开点击进入workspace和拖动窗口,因此,拖动只能分配为鼠标右键了,

Tue 14 Jun 2016 02:20:59 AM NZST
mpv启动自动最大化，没有黑边了

Tue 14 Jun 2016 03:12:29 AM NZST
而且compiz0.9有无法switch到minimalize窗口的问题

Tue 14 Jun 2016 03:38:52 AM NZST
blur在屏幕旋转后效果奇怪。
compiz0.8和arc的透明效果不相容,不过反正也不是很明显
 
但是,虽然透明效果消失了,gnome3程序tile却变准确率,或许是因为原先带来透明效果的组件让xprop变得不准确的吧,所一在其失效后,tile又正常了

Tue 14 Jun 2016 11:23:57 AM NZST
实际用的时候，的确很难确保,在修改了ini之后,compiz会重新加载它

Tue 14 Jun 2016 12:01:04 PM NZST
其实,firefox崩溃的时候依然会有丢失focus的问题,
但是单纯的关闭,似乎不会丢失focus

Tue 14 Jun 2016 01:36:27 PM NZST
和0.9比起来,在用tile调整窗口的效率方面,0.8明显弱很多,cpu占用能到99%并且挤占其他进程资源,比如音频出现卡顿.

***  emerald
Wed 15 Jun 2016 01:27:44 AM NZST
一个问题,开机的时候emerald会崩溃一次,原因似乎和switcher有关,swithcher有着似乎不同一般窗口的decro,启动emerald的时候你才能看到
这是0.8的问题,switcher的title在switcher底部造成的吧,0.9是在顶部,而且缺了文字,所以0.8的behavior才是正常的,但是这样的化,开机后,用了swicher之后emerald就会崩溃,就只能手动重启一次了.
或许,如果我们关闭compiz的decro,自己来启动emerald呢?但是emrald必须要在compiz之后启动吧?那么我们用谁来卡startx线程呢?
我想emerald必须要在compiz中配置的原因是因为它对compiz有依赖吧?我们来试试看能不能独立用emerald?
启动倒是没有问题，就是看不到效果

解决办法是，把emerald做成循环线程,看样子,switcher的确让emerald崩溃了,不过循环的话,就会自动启动了.
不过循环其实不太好.
既然崩溃次数是有限,做成二次/三次执行比较好.

compiz decro除了emerald 还要管理窗口阴影,所以有必要开着.

*** blur
**** root
 Wed 15 Jun 2016 12:55:04 PM NZST
 好奇怪,reddit上面那个compiz用的滤镜明显改觉比我的大很多,难道他改源码了?

 Wed 15 Jun 2016 01:57:35 PM NZST
 https://github.com/compiz-reloaded/compiz/commit/523c2ab814422e4d88ba89bcfa01cfc37ff75bd6
 我想这是了解compiz blur kernel的关键.
 主要的差别是,0.8存放kernel的手法似乎和compton不一样,并不是矩阵形式的,我估计是为gaussian特别设计的一维数组.
 似乎找到了,buffer似乎是2048的限制

 实际上代码中似乎有很多1024 2048的限制,1024和28**2很接近

 麻烦的是,gpu操作方面,感觉其中似乎混杂了一些很像汇编的东西
 已知存在的大数字:
 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 32, 50, 100, 200, 1000, 1024, 2007, 4096, 8192, 65535, 1000000, 20070830
 73以下可以排除嫌疑.
 50是我设置的,100是option,200也是我设置的,1000是time,大概是毫秒
 1024出现很多,最可疑
 2007是年份
 4096也很可疑,但是看着像是存放gl程序的字符串
 8192似乎是window property
 65535以上似乎就太大了,应该是无关的的.
 因此,重点排查应该是1024了.
 的那是很多1024似乎都是char类型,估计是字符串
 检查过后觉得,1024的确只是字符串,而且也不涉及循环,是定长字符串
 但是,4096倒是挺可疑的,因为其中涉及了循环了.
 循环次数是numTexop,numTexop被bs->amp引用了找不到numTexop的赋值.
 amp的大小是  BLUR_GAUSSIAN_RADIUS_MAX
 所以感觉这里是存在关联性的.那么我们就试下吧

 哈哈，一次到位，果然是这里的数组溢出了.

 Wed 15 Jun 2016 04:04:27 PM NZST
 进一步的问题，提升radius现在不会导致compiz崩溃了,
 但是,如果我们设定str为0.1,那么radius到30以后,似乎就没有进一步的效果了.
 如果str为0,那么极限是i,
 如果str为0.01,效果似乎和0一样,有奇怪的小数点溢出问题.
 因为似乎用了一个pascal的整数算法,我想的确是哪里的小数位数溢出了.
 到头来,极限效果依然和15/0.1比没有差别

 Wed 15 Jun 2016 04:13:06 PM NZST
 进一步的源码分析,我们可疑假设下,amp变量就是kernal,那么我们可疑改动amp,来确认下,
 改动amp为中心为1,其余为0,那么就是普通的transparent了.
 模仿过后,我们知道,当str为0的时候,其实不是guassian效果,kernel恒为1.0

 我怀疑,ccsm无法传递太小的数字到程序,那么我们不如在blur.c中设定strength为1/100,然后在ccsm中可疑用更高精度调整strength

 Wed 15 Jun 2016 04:58:23 PM NZST
 寻找radius极限的办法很简单,设定strength为0,radius在10,和希望的数值之间切换,会产生差异效果.
 极限是50,50以上切换依旧是10的效果.compiz没有崩溃,大概和之前的崩溃不同,不涉及cpu溢出,
 我想崩溃的是gpu编译,编译失败,所以没有生成新的效果,
 因此确认了上限是50,

 对应的,strength的下限是0.05,否则会觉得blur效果似乎变方了.

 总得来说勉强比初始的15/0.1效果好一些

 和compton不同的是,虽然radius设到了50,但是没有感觉到性能下降

 Wed 15 Jun 2016 06:15:50 PM NZST
 确认是用的是ARB assembly language
 也就是汇编咯

 Wed 15 Jun 2016 06:25:50 PM NZST
 尝试输出汇编后发现，radius超过50的时候，似乎在得到汇编之前，就产生错误了

 Wed 15 Jun 2016 06:33:10 PM NZST
 更为奇异的是，如果设定radius为12，然后改到120，12会输出一次arb，120不会，
 但是如果更改str，这个时候会输出arb,而且其中的数值就是12,而不是120
 就好象120 在哪里被截获了,而内部变量依旧是12
 在哪里截获的呢?
 原来是我自己之前忘了把那个数值改到200了

 这样子就什么都解决了。
 比较合适的数值是radius100，在拖动窗口的时候，略微可以感觉到有点迟缓,有点性能吃力,这个程度刚刚好.
 比compton性能好很多,compton是达不到这个水平的.应该是因为这个程序优化过了.
 对应的strength可疑设定在.03,那么在中位,的数值是0.076(对比正中心),边界是0.003,这样的边界似乎有些多余,我们可以适当缩减边界,减少性能消耗.
 其实这里的边界适宜度,应该通过积分来计算,到底有百分之多少被丢弃了.太麻烦了,所以就大概估计下吧.

 调整到80/.03,这样边界就是0.012了,这个数值应该差不多了

 Wed 15 Jun 2016 06:51:30 PM NZST
 一个问题是blur和wall一起用的时候,如果radius到了100,3x3的workspace,那么耳机会有电流声,
 80 radius的时候,不论3x3还是5x5,启动wall的一瞬间有电流声音,之后就没有了.
 这一点而且和当前桌面开启的程序也毫无关系.
 不论把wall中的颜色改成全部实色还是全透明也没有帮助.这中情况下照理blur是不工作的.
 不过,反正我们用radius80,所以全部问题到此了解

 但是,如果桌面上有blur,开启wall的话,即时80也会有噪音
 当然问题根本是这台电脑电源管理有问题.
 另外,和reddit对比起来,80 0.03还远不及其效果吧.感觉他的radius可能达到200了,概不会是ps的吧.
 不过docky看起来有点接近mac了,估计mac或许radius在150左右.
 总觉得reddit那份可能是400,500左右,我看我150的效果还不及他一半

 现状是,我们可疑调整到190,性能并无大碍,虽然有耳机噪音

 190的效果已经和mac很想像,虽然达不到reddit的程度,但是我想如果我们进一步提升可能就过头了,因为颜色会都混到一起去的.
 800会卡到动弹不得。
 500是性能极限，开机可能无法加载wallpaper，wall完全不流畅，expo中窗口没有blur
 300wall还是不流畅,expo也没有blur
 200wall就只是轻微不流畅，expo与其说是没有blur，不如说是blur效果怪异，太黑了.
 100似乎就没什么问题了,除了电流声
 80在有blur窗口的情况下有电流声
 50没有

 之前我说错了，电流声不是耳机里的，好像是机箱里的

 不考虑电流声音的话,日常可以用150,差不多感觉是mac等级了,80的话就会感觉到有差异,差异就是80能勉强分辨背景细节,mac是几乎模糊掉这些细节的.
 要截图像reddit的话,可以上500,接近一个光滑平面.虽然略卡,但是不调用expo和wall的话,其实大问题也没有.

 Wed 15 Jun 2016 08:12:39 PM NZST
 有一个问题,0.8 的blur是依据alpha决定的,
 但是qml的shadow也是属于alpha的,所以这些shadow会产生blur效果,细看会有点怪异.
 解决方法很简单,想办法把这部分qml排除就可以了,不过这只前我们要先学会编译qml

 整体上来说,我还是喜欢透明的qml而不是blur的,因为qml总是占据很大面积,blur并不好,所以暂且把qml排除blur之外吧.

 2016-07-05 07:53:19 Tue NZST
 compiz blur是依据opacity来调整blur强度的.
 因此只有opacity高的时候,blur才会有效果,低的时候就没有效果.
 我们可以做成根据opacity mod 4,来调整blur强度.

 确切的说,眼下的机制是0.25以上,blur有效,以下,是看似原图和blur的混合物.也就是说原图的细节被保留了.

 看来似乎是没有blur强度一说了,blur强度是固定的,但是blur似乎作为另一个层,有自己的透明度

 2016-07-06 20:33:45 Wed NZST
 有一个bug,在rotation之后,blur会异样,blur被拉长,原因应该是因为高宽比被放入了gl程序了
 而rotation之后程序没有重新编译.
 这个时候在ccsm中调整下参数出发程序重编译的话,就会修正这个问题.

 2016-07-06 21:57:56 Wed NZST
 compiz blur机制理解.
 第一,靠后的窗口blur的时候,会混入靠前的窗口的颜色.
 这说明,流程是,先画好整个桌面,包括透明度
 然后找到当前窗口需要alphablur的区域,在这个区域以整个桌面,除当前窗口以外进行blur.
 能排除当前的话,其实应该也可以排除靠前的窗口,所以没有排除掉其实很奇怪.

 blur完毕,生成texture,这个时候,依据alpha强度,在0.25以上的话,完全用blur替代,但是在以下的话,会变成alpha和blur的混合效果,依据alpha来调整效果比例.
 然后,这里的两处alpha都不是全局性的,而是texture中的alpha频道,否则的话就无法处理不定型了.
 由于是alpha频道,所以处理必然是交个了gl而不是c
 也就是说,是gl计算出了融合所需要的alpha.
 至少,在生成blur的时候,需要附加上窗口自身的alpha强度(然后乘以4?)

 这里有一个问题是,窗口自身的背景是作为独立图层在后期与blur合并的,还是说一早
 就融入到了blur算法中呢?

 程序中有两个关键词,dst和src,是alpha算法相关的关键词.
 source是新加入的,destination是已经存在的,所以source可以考虑作为前景,也就是窗口自身.
 而destination就是背景了.

 由于程序中出现了这两个词,所以很有可能,alpha算法是这个程序处理处理掉的,而不是交由外部.

 2016-07-06 22:32:44 Wed NZST
 因为进一步搞下去好像挺麻烦的,所以还是暂停吧.
 现在的目标是,消除alpha和blur的耦合,以便把alpha降到0.25以下.
 现在的进程是,从比较简易的srcFun入手,来检查,程序是如何把alpha混合到blur中的.
 blur.c line 1056, srcFun很短,唯有的参数似乎只有一个0.25,虽然看似不怎么像.
 检查这个数值需要重新编译compiz-core,不过我怕弄坏现有的compiz包,所以还是算了,
 想要做这个测试,至少应该要在有备份恢复机制的情况下.

 2016-07-07 02:21:21 Thu NZST
 如此的话其实compiz比起compton的blur并不太好,果然后出的软件架构会更好.
 但是compiz 的算法却是优化了很多的,估计是为了当时落后的硬件.结果是现在硬件更好之后,compiz的blur就可以使用比compton大的多的高斯半径了,到300似乎都没什么问题.
 但是由于alpha和blur混合的原因,到300如果不降低alpha的话,会觉得效果比较差.所以只能用到150了.但是相比之下我记得compton的算法只能扩展到50-80,

 从质地上来说,带有alpha的效果接近于磨砂玻璃.
 完全消除alpha可以展现不一样的质地.

 2016-07-07 09:54:57 Thu NZST
 line 1332 分析

 //output是dst的原有,sum是blur计算? sum*dst.a + output
 //但是sum似乎没有blur效果.output也没有.两者独立都看不出效果.
 //output是dst,sum是blur计算,mask来自output.a和env
 //比较难以理解的是output.a
 //output的最终输出是窗口北京,所以output.a太低的话,就会无法掩盖真实背景
 //但是output.a不能乱设,无法单纯依赖它去改变透明度,会有异常效果.
 //似乎是这样的,mask提供了整体的alpha,然后分成output和sum两份,
 //在这里合并这两份,然后以mask的数值输出.
 //纯sum的结果是,依旧会被25限制,同时窗口前景变淡了.
 //也就是说,原本需要被mask掉不做blur的前景被牵扯了.
 //纯output的结果是25以上,可以消除透明,背景色(白)相当于乘以了alpha.
 //如此看来,25的问题或许不是这部分代码可以管理的?
 //和mask有关吗?调整output.a的话,可以超出mask限制,但是会打破界面其他部分的约束?
 似乎mask就是threshold.但是trheshhold似乎是int强转float,这种东西怎么可能作为alpha来用呢?

 抓取的xgetwindowproperty propdata是,
 _COMPIZ_WM_WINDOW_BLUR
 看不出来这是什么.但是看来threshhold是外界定下来的.
 0.25的限制可能是来自这里吗?感觉不太像.
 取[0]位作为threshold

 分析以下,纯output的结果.
 output.a=mask,
 dst.a=0
 output.rgb=output.rgb
 output.a=output.a=mask

 _SAT是clip(0,1)的意思,所以mask 是env和output.a的乘积,并且在0,1之间.
 当然,我们怀疑env把a收缩掉了.

 纯output的情况下,为什么背景色会被alpha降低?
 至少了解一点就是sum的确是blur,output则似乎是背景色,包括前景,包括alpha.
 sum会占据掉output输出alpha不足的部分.与其融合得到新的颜色.

 奇怪的地方是,如果alpha<0.25,不只是sum和output,原本的毕竟也会参与进来融合.

 根据这部分代码来看,sum需要乘以dst.a才能加入output,所以output本身其实已经乘以过output.a了.

 现在的问题是,当alpha很低的时候,当然output不会起作用,但是sum也不起效果.
 解决办法是,把alpha拉高到0.25作为起点.
 mask限定了总的alpha,然后output.a会在output和sum之间分配.
 现在要想办法,把其看做0.25为起点,重新分配.
 a2=a-0.25 / 0.75 
 ouput=ouput/a * a2=output * (a-0.25)/0.75 *a
 dst.a=mask -  (a-0.25)/0.75

 麻烦的一点是,arb代码不知道在哪里出错.

 总结一下,
 纯blur的情况下,照理是要消除output的,不过我们没这么干,所以出现了模糊的前景.
 纯output的情况下,blur被消除了,但是output自身需要重新调整恢复色彩.
 纯output的情况下,如果alpha降到0.25以下,会出现透明,这个现象还不确定.
 确认output.a可以直接设为1.0,掩盖掉其他东西.没有奇怪的颜色出现.
 确认可以将output和sum的组合设为1.0,那么alpha为0的时候,blur也就有效了.

 下面的问题是,如何给予特定部分的alpha为0?
 现在的组合为1.0,但是显然mask的情况并非如此.实际上我们需要的是,拉高mask的阀值,把更多mask拉到1.0,但是要保留最小的部分
 或许threshhold就是这么干的,alpha*4的话,那么0.25以上都会被拉高到1了.

 猜中了,
 所以threshold加到40的话,0,1,2以外的alpha都可以消除背景透明了.
 这个threshold的源头似乎是 xprop的_COMPIZ_WM_WINDOW_BLUR属性,但是网上没有找到doc解释,所以不清楚是否所有window可以共享同一个数值.但是暂且这么做似乎也没什么问题.

 2016-07-07 12:01:00 Thu NZST
 大体来说,0 alpha和白色磨砂是材质.
 不过0 allpha要求更大的blur半径,但是白色磨砂在大半径下的效果就不那么好了.
 所以两者混用的话,其实还是最好还是能够区分窗口分配filter.

 另外,单单一个材质的意义不大,组合分配材质的效果才会比较好,如果qtcurve能够像gtk一样区分布局分配材质就好了

 不过我们倒是做第三个terminal来产生组合效果.
 但是意义也不大,毕竟平时我几乎不会用blur的term.
 唯有像是osx一样用在dock上,但是这个也是平常用不到的.
 而rofi需要白色磨砂来提高对比度.

 用在docky上对应到偏黑背景的时候,效果还是很明显的.

 2016-07-07 12:17:02 Thu NZST
 由于降低threshold降低造成的一个问题,
 docky右键菜单有虚假阴影,被判别为blur了,不过提供全透明虚假阴影的软件也不多.
 解决办法是,约定几个特殊的alpha数值,作为blur专用.

 2016-07-07 12:33:28 Thu NZST
 好像除了docky外,可以用到0 alpha的地方并不多,毕竟0 alpha原本都是要有阴影来配合各种色彩的.
 所以比起文字,和图标的相性大概更好些,前提是你有用到图标的场合.
 其实倒是可以配合switch来用.不过,那里并不能调色彩.
 expo wall也不错,不过测试blur无效.

 2016-07-08 09:09:36 Fri NZST
 0 alpha 的材质感确切说是像是镜子,虽然照理说镜子是看不见.不过就是有这种感觉.可能是在什么场景中看到过的镜子的感觉.
**** 模仿
*** blur compton对比
Tue 14 Jun 2016 04:59:00 PM NZST
0.8实现blur的手法和compton不同,
compton的blur效果是固定的,0.8却是依据上层的alpha变动的.
这给予了上层窗口控制blur效果的余地,但是也把blur和alpha的概念混淆在了一起.
或许实际上,要表现blur效果,alpha通道之外就有必要加入一个blur通道?
3D引擎中现在是如何处理blur的呢?
我知道的有曲面折射和曲面反射,漫反射,前面两者都是属于点对点的映射.
光线追踪呢?似乎也是点对点映射的领域
不过有个比较流行的技术,远景blur,这个的确是blur技术,
unity 中的名字是DepthOfFieldFunction,似乎是通过depth map做的处理

Wed 15 Jun 2016 12:39:21 AM NZST
0.8用的这个策略,虽然说概念上不够严谨,但是功能上来说却是挺不错的,全局性的blur效果其实并不好,纯透明的terminal是必要的,compton无法区分透明和blur,就无法共用这两者了.

所以如果我们想用wayland重现的话,应该要考虑一个贴近0.8的模型而不是wayland的模型,
不过,其实compton对于仅仅区分透明和blur是可以做到的,只要在compton窗口过滤器中标志下哪些window需要blur就可以了.
确切的说compton模型的缺点在应对docky的时候才会发生,因为docky在一个窗口内,需要区分blur的区域和透明的区域来画出特定的形状,compton结合docky的时候,似乎会把docky占据的区域整个绘制为blur.
我记得不是很清楚了,因为好像没有结合compton和docky共用的印象.
* theme
** gtk
   2016-07-08 04:41:15 Fri NZST
arch下用的gtk theme

arc 和adapta都是完成度很高,并且紧跟gtk标准的主题.但是问题是thunderbird下它们focus左右栏目的颜色是一样的,完全看不出到底当前focus的是哪一个.


2016-07-08 04:50:35 Fri NZST
测试的结果是ubuntu和xfce系的theme可以区分focus,kde和gnome系,以及一堆第三方github theme无法做到.
我想原因在于所有的第三方theme其实是从第一方出发来改动的,而不是完全自己实现的,所以,第一方的特征就遗传到第三方了.

ubuntu和xfce的问题是,thunderbird顶部的tab曲线显示不正常.

不过,不起眼的thinice和industrial 还是又high contrast主题似乎可以同时解决这两个问题.
不知道这两个theme是怎么安装的,可能是跟随gnome,kde,xfce安装进来的?跟随gnome一起安装的可能行比较大.

其中industrial看起来还是挺顺眼的.就是scrollbar略丑.
但是这些古旧的theme对于gnome3系的软件支持就很差了.

眼下来说,tab的时候需要检查focus位置的软件只有thunderbird,
其实平时最常用的gtk软件是firefox,其他一般都是用term的,所以gtktheme到底长什么样其实也不是很重要.
不过,似乎firefox没有被industrial的theme影响到,而是用了gtk3的theme?

2016-07-08 05:17:21 Fri NZST
bash中可以通过设定环境变量来改变firefox调用的theme.所以industrial theme可以独立分配给thunder bird
** 色彩
2016-07-16 08:32:43 Sat NZST
白色主题优于黑色主题的原因或许是,像一张白纸一样的界面,从人的主观感受看,是等着人在其上进行创作.
* 准则
** 过度特化
 Wed 01 Jun 2016 06:35:53 AM NZST
 过度特化的结果是,很多软件特性都被我丢掉了,然后,很多操作都是命令行相关了.

 这主要应该是按照我的需要,这些特性都没有用的原因吧.
 但是对其他人来说,他们是否需要呢?我并不清楚,他们自己也不一定清楚
* wallpaper
** source
 Thu 26 May 2016 01:43:22 PM NZST
 可以在youtube上找找歌曲背景
